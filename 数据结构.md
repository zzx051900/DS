- 网课视频
  - 青岛大学王卓（共173）：10，11，12，13，14，**15**，**16**，17，18，19，20，21，22，23，24，25，26，27，28，29，30，31，32，33，34，35，36，37，38，39，40，41，42，43，44，45，46，47，48，49，50，51，52，53，54，55，56，57，**58**，59，60，61，62，63，64，65，66，67，68，69，70，71，72，73，74，75，76，78，79，80，81，82，83，84，85，86，87，88，89，90，91，92，93，94，95，96，97，98，99，100，101，102，103，104，105，106，107，108，109，110，111，112，113，114，115，116，117，118，119，...，122...，137，138，139，140，141，142，**143**，144，145，146，147，148，149，150，151，152，153，154，155，156，157，158，159，160，161，**162**，163，164，165，166，167，168，169，170
- 注意：类C语言使用引用传参(&)，是借用C++语法中的内容，C语言实现时使用指针(*）传参，与类C代码有很大不同
- 数字编号分级：
  - 第一层为汉字数字加顿号，例如：一、二、三、；
  - 第二层为括号中包含汉字数字，例如：（一）、（二）、（三）； 
  - 第三层为阿拉伯数字加下脚点，例如：1.、2.、3.；
  - 第四层为括号中包含阿拉伯数字，例如：（1）、（2）、（3）； 
  - 第五层为小写英文字母，例如：a、b、c；


[TOC]



# 基本结构

- 数据结构的基本概念
  - 第一章 绪论

- 基本数据结构

  - 线性结构

    - 第二章 线性表

    - 第三章 栈和队列

    - 第四章 串、数组和广义表

  - 非线性结构
    - 第五章 树
    - 第六章 图

- 基本数据处理技术

  - 第七章 查找
  - 第八章 排序

# 一.绪论

- 程序 = 数据结构 + 算法
- 基本结构：
  - 数据结构的基本概念（绪论）
  - 基本数据结构
    - 线性结构
      - 线性表
      - 栈和队列
      - 串
      - 数组和广义表

    - 非线性结构
      - 树
      - 图

  - 基本数据处理技术
    - 查找
    - 排序


## （一）数据结构的研究内容

- 数据结构是一门研究非数值计算的程序设计种计算机的操作对象以及它们之间关系和操作的学科

## （二）基本概念和术语

## （三）抽象数据类型的表示和实现

## （四）算法和算法分析

# 二.线性表

## （一）线性表的定义和特点

- 线性表是具有相同特性的数据元素的一个有限序列，由n（n>=0）个数据元素（结点）a1、a2、a3...组成的有限序列
  - 其中数据元素的个数n定义为表的长度
  - 当n=0时称为空表
  - 将非空的线性表（n>0）记作：（a1，a2，...，an）
  - 这里的数据元素ai只是一个抽象的符号，其具体含义在不同情况下可以不同

- 案例：稀疏多项式的运算

  - 创建一个新数组c
    - 分别从头遍历比较a和b的每一项
      - 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项
      - 指数不相同：则将较小项复制到c中
  
  
    - 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可
  


## （二）线性表的基本操作：

1. `InitList(&L)`

   - 线性表的初始化
   - 操作结果：构建一个空的线性表L

2. `DestroyList(&L)`

   - 销毁线性表

   - 初始条件：线性表L已经存在
   - 操作结果：销毁线性表L（表本身消失）

3. `ClearList(&L)`

   - 清空线性表
   - 初始条件：线性表L已经存在
   - 操作结果：将线性表L重置为空表（表仍存在）

4. `ListEmpty(L)`
   - 线性表判空
   - 初始条件：线性表L已经存在
   - 操作结果：若线性表为空，则返回TURE；否则返回FALSE
   
5. `ListLength(L)`
   - 求线性表长
   - 初始条件：线性表L已经存在
   - 操作结果：返回线性表中元素个数
   
6. `GetElem(L,i,&e)`

   - 线性表取值
   - 初始条件：线性表L已经存在，1<=i<=ListLength(L)
   - 操作结果：用e返回线性表L中第i个元素的值

7. `LocateElem(L,e,compare())`

   - 初始条件：线性表L已经存在，compare()是数据元素判定函数
   - 操作结果：返回L中第一个与e满足compare()的数据元素的位序，若不存在，则返回0

8. `PriorElem(L,cur_e,&pre_e)`

   - 初始条件：线性表L已经存在
   - 操作结果：若cur_e，是L的数据元素，且不是第一个，则用pre_e返回他的前驱，否则操作失败，pre_e无意义

9. `NextElem(L,cur_e,&next_e)`

   - 初始条件：线性表L已经存在

   - 操作结果：若cur_e，是L的数据元素，且不是最后一个，则用next_e返回他的前驱，否则操作失败，next_e无意义

10. `ListInsert(&L,i,e)`

    - 线性表的插入
    - 初始条件：线性表L已经存在，i<=i<=ListLength(L)+1
    - 操作结果：在L的第i个位置前插入新的元素e，L的长度加一

11. `ListDelete(&L,i,&e)`

    - 线性表的删除
    - 初始条件：线性表L已经存在，i<=i<=ListLength(L)
    - 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一

12. `ListTraverse(&L,visited())`

    - 遍历线性表
    - 初始条件：线性表L已经存在
    - 操作结果：依次对线性表L中每个元素调用visited()

## （三）算法中用到的预定义常量和类型

- ```c
  //函数结果状态代码
  #define TRUE 1
  #define FALSE 0
  #define OK 1
  #define ERROR 0
  #define INFEASIBLE -1
  #define OVERFLOW -2
  //Status 是函数的类型，其值是函数结果状态代码
  typedef int Status;
  typedef int ElemType;
  typedef char ElemType;	//根据需要改成自己需要的类型
  ```

## （四）顺序表

### 1.顺序表的定义：

- 用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。

### 2.顺序表中元素存储位置的计算

- 假设线性表的每个元素需占用i个存储单元，则第i+1个元素的存储位置和第i个元素的存储位置之间满足关系：
  - `LOC(a(n+1))=LOC(a(n))+i`

### 3.顺序表的特点

- 以物理位置相邻表示逻辑关系，任一元素均可随机存取
  1. 地址连续
  1. 依次存放
  1. 随机存取
  1. 类型相同


### 4.顺序表的代码实现

- 结构定义：

  - 类C语言代码：
  
    - ```c
      #define LIST_INIT_SIZE 100	//线性表存储空间的初始分配量
      typedef struct
      {
          ElemType elem[LIST_INIT_SIZE];	//方案1：静态数组方式
          ElemType *elem;	//方案2：动态内存分配方式
          int length;	//当前长度（当前项个数）
      }SqList;
      SqList L;//定义变量L，L是SqList这种类型的变量，L是个顺序表
      L.elem=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);//动态内存分配
      ```
  
  - C语言代码实现：
  
    - ```c++
      //顺序表数据结构
      typedef struct
      {
      	ElemType *elem;
      	int length;
      }SqList;
      SqList L;
      L->elem = (ElemType*)malloc(MAXSIZE*sizeof(ElemType));	//动态分配内存，创建头结点，指针传递，所以箭头
      ```
  


- 多项式的顺序存储结构类型定义：

  - ```c
    #define MAXSIZE 1000  //多项式可能达到的最大长度
    typedef struct  //多项式非零项的定义
    {
        float p;//系数
        int e;//指数
    }Polynomial;//多项式
    typedef struct
    {
        Polynomial *elem;//存储空间的首地址，以自定义数据类型建立的数组
        int length;//多项式中当前项的个数
    }SqList;//多项式的顺序存储结构类型为SqList
    ```

- 图书表的顺序存储结构类型定义

  - ```c
    #define MAXSIZE 10000  //图书表可能达到的最大长度
    typedef stcuct  //单本图书信息定义
    {
        char no[20]; //图书ISBN
        char name[50]; //图书名字
        float price; //图书价格
    }Book;
    typedef struct
    {
        Book *elem; //存储空间的基地址
        int length; //图书表中的当前图书个数
    }SqList; //图书表的顺序存储结构为SqList 
    ```

### 5.顺序表基本操作的实现（代码）

  #### 算法1：线性表L的初始化（参数用引用）

- 类C代码：

  - ```c
    Status InitList_Sq(SqList &L)		//构造一个空的顺序表L
    {
      L.elem=new ElemType[MAXSIZE];	//为顺序表分配空间
      if(!L.elem)
          exit(OverFLOW);				//存储分配失败,异常处理
      L.length=0;						//空表长度为0
      return 0;
    }
    ```

- C语言实现：

  - ```c++
    Status InitList_Sq(SqList* L)
    {
    	L->elem = (ElemType*)malloc(MAXSIZE*sizeof(ElemType));	//动态分配内存，创建头结点
    	if (!L->elem)	//异常处理，检查存储空间是否分配成功
    		return ERROR;
    	L->length = 0;	//表中元素为0
    	return OK;
    }
    ```

#### 算法2：销毁线性表L    

- 类C代码：

  - ```c
    void DestroyList(SqList &L)
    {
        if(L.elem)
            delete L.elem;  //释放空间，C++语法，具体C语言代码实现不是这样
    }
    ```

- C语言实现：

  - ```c
    void DestroyList_Sq(SqList* L)
    {
    	if (L->elem)	//如果数组不为空，则释放这块内存空间
    		free(L->elem);
    	L->length = 0;
    	L->elem = NULL;
    }
    ```

#### 算法3：清空线性表L

- 类C代码：

  - ```c
    void ClearList(SqList &L)
    {
        L.length=0;  //将线性表长度置为0
    }
    ```

- C语言实现：

  - ```c
    void ClearList(SqList* L)
    {
    	L->length = 0;
    }
    ```

#### 算法4：求线性表长度

- 类C代码：

  - ```c
      int GetLength(SqList L)
      {
          return (L.length);
      }
    ```

- C语言实现：

  - ```c
    int GetLength(const SqList* L)
    {
    	return L->length;
    }
    ```

#### 算法5：判断线性表L是否为空

- ```c
   int IsEmpty(SqList L)
    {
        if(L.length==0)
            return 1;  //若为空，则返回1
        return 0;
    }
  ```

#### 算法6：顺序表取值（根须位置i获取相应位置数据元素的值，用e返回）

- 类C代码：

  - ```c
     Status GetElem(SqList L,int i,ElemType &e)
      {
          if(i<1||i>L.length)
              return ERROR;  //判断i值是否合理，若不合理，返回ERROR
          e=L.elem[i-1];  //第i-1个单元存储着第i个数据
          return OK;
      }
      //随机存取，时间复杂度为O(1)
    ```

- C语言实现：

  - ```c
    Status GetElem_Sq(SqList L, int i, ElemType *e)
    {
    	if (L.length==0 || i<1 || i>L.length)
    		return ERROR;  //判断i值是否合理，若不合理，返回ERROR
    	*e = L.elem[i - 1];  //第i-1个单元存储着第i个数据
    	return OK;
    }
    ```

#### 算法7：顺序表的查找

- ```c
    //在线性表L中查找与指定值e相同的数据元素的位置
    //从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，则返回0
    int LocateElem(SqList L,ElemType e)
    {
        for(int i=0 ; i<L.length ; i++)
        {
            if(L.elem[i] == e)
                return i+1;//eg:数组a[0]的位置序号是1
        }
        return 0;//未找到，返回0
    }
  ```

#### 算法8：顺序表的插入

- 类C代码：

  - ```c
     /*算法思想：
      1.判断插入位置i是否合法(i<1||i>L.length+1)
      2.判断顺序表的存储空间是否已满，若已满则返回ERROR
      3.将第n至第i位的元素依次向后移动一个位置，空出第i个位置
      4.将要插入的新元素放入第i个位置
      */
      Status ListInsert_Sq(SqList &L,int i,ElemType e)
      {
          if(i<1||i>L.length+1)
              return ERROR;   //i值不合法
          if(L.length==MAXSIZE)
              return ERROR;   //当前存储空间已满
          for(j=L.length-1;j>=i-1;j++)
              L.elem[j+1]=L.elem[j];    //插入位置及之后元素后移
          L.elem[i-1]=e;  //将新元素e放入第i个位置
          L.length++;     //表长加一
          return OK;
      }
    ```

- C语言实现：

  - ```c
    Status ListInsert_Sq(SqList *L, int i, ElemType e)
    {
    	if (i<1 || i>L->length + 1)	//eg:一共有10个元素(L->length=10)，插入在最后位置的话相当于插入在第11个元素之前，所以i最大只能为L->length+1
    		return ERROR;
    	if (L->length == MAXSIZE)
    		return ERROR;
    	if (i <= L->length)	//若插入位置不在表尾，要移动元素
    	{
    		for (int j = L->length - 1; j >= i - 1; j--)	//表中最后一个元素的下标为L->length-1
    		{
    			L->elem[j + 1] = L->elem[j];
    		}
    	}
    	L->elem[i - 1] = e;	//将新元素插入
    	L->length++;	//表长加一
    	return OK;
    }
    ```

#### 算法9：顺序表的删除

- 类C代码：

  - ```c
      /*算法思想：
      1.判断删除位置是否合法(1<i<n)
      2.将第i+1至n位的元素依次向前移动一个位置
      3.表长减一，返回OK
      */
      Status ListDelete_Sq(SqList &L,int i)
      {
          if(i<1||i>L.length)
              return ERROR;   //i值不合法
         for(j=i;j<L.length-1;j++)
              L.elem[j-1]=L.elem[j];   //元素前移
          L.length--; 
      }
    ```

- C语言实现：

  - ```c
    Status ListDelete_Sq(SqList *L, int i, ElemType *e)
    {
    	if (L->length == 0)
    		return ERROR;
    	if (i<1 || i>L->length)
    		return ERROR;
    	*e = L->elem[i - 1];
    	if (i < L->length - 1)	//如果删除位置不在最后，需要移动元素；如果在最后，则只需要表长减一
    	{
    		for (int j = i - 1; j <= L->length - 2; j++)
    		{
    			L->elem[j] = L->elem[j + 1];
    		}
    	}
    	L->length--;	//表长减一
    	return OK;
    }
    ```

#### 顺序表完整代码演示

- ```c
  #define _CRT_SECURE_NO_WARNINGS
  #include<stdio.h>
  #include<stdlib.h>
  
  #define MAXSIZE 20	//线性表初始分配量
  #define OK 1	//成功标志
  #define  ERROR 0	//失败标志
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int ElemType;	//ElemType的类型根据实际情况而定，这里假定为int
  
  //顺序表数据结构
  typedef struct
  {
  	ElemType *elem;
  	int length;
  }SqList;
  
  //函数声明
  Status InitList_Sq(SqList *L);	//顺序表的初始化
  void DestroyList_Sq(SqList* L);	//顺序表的销毁（销毁还存在问题）
  void ClearList(SqList* L);	//清空顺序表
  Status GetLength(SqList L);	//求顺序表长度
  Status IsEmpty(SqList L);	//判断顺序表是否为空
  Status ListInsert_Sq(SqList *L, int i, ElemType e);	//顺序表的插入
  Status ListDelete_Sq(SqList *L, int i, ElemType *e);	//顺序表的删除
  Status GetElem_Sq(SqList L, int i, ElemType *e);	//顺序表的取值
  Status LocateElem(SqList L, ElemType e);	//顺序表的查找
  void Output(SqList L);	//打印顺序表
  
  int main()
  {
  	SqList L;
  
  	printf("顺序表的初始化\n");
  	InitList_Sq(&L);
  	Output(L);  //打印结果
  
  	int f = 1;	//用于跳出循环
  	while (f)
  	{
  		printf("---------------------------------------------------------------------------\n");
  		printf("请选择要进行的操作：\n");
  		printf("1.插入数据	2.删除数据	3.判断顺序表是否为空	4.求顺序表长度	5.顺序表取值\n");
  		printf("6.清空线性表	7.销毁线性表	8.线性表的查找		9.尾插建立顺序表	10.退出\n");
  
  		int select = 0;
  		int n = 0;
  		int e = 0;
  		int i = 0, m = 0;
  		scanf("%d", &select);
  		switch (select)
  		{
  		case 1:
  		{
  				  printf("请输入插入的位置 i 及元素的值 m ：");
  				  scanf("%d %d", &i, &m);
  				  ListInsert_Sq(&L, i, m);
  				  Output(L);  //打印结果
  				  break;
  		}			
  		case 2:
  		{
  				  printf("请输入要删除的是第几个元素：");
  				  i = 0;
  				  scanf("%d", &i);
  				  ListDelete_Sq(&L, i, &e);
  				  Output(L);  //打印结果
  				  printf("删除的数据为：%d\n", e);
  				  break;
  		}		
  		case 3:
  		{
  				  int flag = IsEmpty(L);
  				  if (flag == 1)
  				  {
  					  printf("顺序表为空\n");
  				  }
  				  else
  				  {
  					  printf("顺序表不为空\n");
  				  }
  				  break;
  		}			
  		case 4:
  		{
  				  int length = GetLength(L);
  				  printf("顺序表长度为 %d\n", length);
  				  break;
  		}
  		case 5:
  		{
  				  printf("请输入要获取第几位元素的值：");
  				  i = 0;
  				  scanf("%d", &i);
  				  GetElem_Sq(L, i, &e);
  				  printf("第 %d 位元素的值为 %d\n", i, e);
  				  break;
  		}		
  		case 6:
  			ClearList(&L);
  			Output(L);  //打印结果
  			break;
  		case 7:
  			DestroyList_Sq(&L);
  			break;
  		case 8:
  		{
  				  printf("请输入要查找元素的值：");
  				  e = 0;
  				  scanf("%d", &e);
  				  i = LocateElem(L, e);
  				  printf("值为 %d 的元素在顺序表中的位序为 %d\n", e, i);
  				  break;
  		}			
  		case 9:
  		{
  				  printf("请输入要插入的元素个数：");			  
  				  scanf("%d", &n);
  				  for (int i = 1; i <= n; i++)
  				  {
  					  
  					  printf("请输入第 i 个元素的值 m ：");
  					  scanf("%d", &m);
  					  ListInsert_Sq(&L, i, m);	//插入位置永远为length - 1前,即尾插
  				  }
  				  Output(L);  //打印结果
  				  break;
  		}		
  		case 10:
  			f = 0;
  			break;
  		default:
  			break;
  		}
  	}
  	return 0;
  }
  
  //顺序表的初始化
  Status InitList_Sq(SqList* L)
  {
  	L->elem = (ElemType*)malloc(MAXSIZE*sizeof(ElemType));	//动态分配内存，创建头结点，初始分配的数组最大容量为MAXSIZE
  	if (!L->elem)	//异常处理，检查存储空间是否分配成功
  		return ERROR;
  	L->length = 0;	//表中元素为0
  	return OK;
  }
  
  //顺序表的销毁
  void DestroyList_Sq(SqList* L)
  {
  	if (L->elem)	//如果数组不为空，则释放这块内存空间
  		free(L->elem);
  	L->length = 0;
  	L->elem = NULL;
  }
  
  //清空顺序表
  void ClearList(SqList* L)
  {
  	L->length = 0;  //将线性表长度置为0
  }
  
  //求顺序表长度
  Status GetLength(SqList L)
  {
  	return L.length;
  }
  
  //判断顺序表是否为空
  Status IsEmpty(SqList L)
  {
  	if (L.length == 0)
  		return 1;  //若为空，则返回1
  	return 0;
  }
  
  //顺序表的插入
  /*
  初始条件：顺序表已经存在
  操作结果：在L中的第i个元素前插入新的数据元素e，表长加一
  算法思想：
  1.判断插入位置i是否合法(i<1||i>L.length+1)
  2.判断顺序表的存储空间是否已满，若已满则返回ERROR
  3.将第n至第i位的元素依次向后移动一个位置，空出第i个位置
  4.将要插入的新元素放入第i个位置
  */
  Status ListInsert_Sq(SqList *L, int i, ElemType e)
  {
  	if (i<1 || i>L->length + 1)	//eg:一共有10个元素(L->length=10)，插入在最后位置的话相当于插入在第11个元素之前，所以i最大只能为L->length+1，i的范围是1到11
  		return ERROR;
  	if (L->length == MAXSIZE)
  		return ERROR;
  	if (i <= L->length)	//若插入位置不在表尾，要移动元素
  	{
  		for (int j = L->length - 1; j >= i - 1; j--)	//表中最后一个元素的下标为L->length-1
  		{
  			L->elem[j + 1] = L->elem[j];
  		}
  	}
  	//若i = L->length + 1，即插入在表尾，则不需要移动元素
  	L->elem[i - 1] = e;	//将新元素插入
  	L->length++;	//表长加一
  	return OK;
  }
  
  //顺序表的删除
  /*
  初始条件：顺序表已经存在
  操作结果：删除L中的第i个元素，并用e返回其值，表长减一
  算法思想：
  1.判断顺序表是否为空，若为空返回ERROR
  2.判断删除位置是否合法(1<i<n)
  3.将第i+1至n位的元素依次向前移动一个位置
  4.表长减一，返回OK
  */
  Status ListDelete_Sq(SqList *L, int i, ElemType *e)
  {
  	if (L->length == 0)
  		return ERROR;
  	if (i<1 || i>L->length)
  		return ERROR;
  	*e = L->elem[i - 1];
  	if (i < L->length - 1)	//如果删除位置不在最后，需要移动元素
  	{
  		for (int j = i - 1; j <= L->length - 2; j++)
  		{
  			L->elem[j] = L->elem[j + 1];	//j + 1 的最大值为 L->length - 1
  		}
  	}
  	//如果在最后(i == L->length - 1)，则只需要表长减一
  	L->length--;	//表长减一
  	return OK;
  }
  
  //顺序表取值（根须位置i获取相应位置数据元素的值，用e返回）
  /*
  初始条件：顺序表已经存在
  操作结果：根须位置i获取相应位置数据元素的值，用e返回
  */
  Status GetElem_Sq(SqList L, int i, ElemType *e)
  {
  	if (L.length == 0 || i<1 || i>L.length)
  		return ERROR;  //判断i值是否合理，若不合理，返回ERROR
  	*e = L.elem[i - 1];  //第i-1个单元存储着第i个数据
  	return OK;
  }
  
  //顺序表的查找
  /*
  在线性表L中查找与指定值e相同的数据元素的位置
  从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，则返回0
  */
  Status LocateElem(SqList L, ElemType e)
  {
  	for (int i = 0; i<L.length; i++)
  	{
  		if (L.elem[i] == e)
  			return i + 1;//eg:数组a[0]的位置序号是1
  	}
  	return 0;//未找到，返回0
  }
  
  //读取（打印）顺序表中所有元素
  void Output(SqList L)
  {
  	printf("当前顺序表的长度为：%d\n", L.length);
  	printf("当前顺序表的元素为：");
  	for (int i = 0; i < L.length; i++)
  	{
  		printf("%d ", L.elem[i]);
  	}
  	printf("\n");
  }
  ```

## （五）链表

### 1.在链表中设置头结点有什么好处？

1. 便于首元结点的处理
   - 首元结点的地址保存在头结点的指针域中，所以在链表第一个位置上的操作和其他位置一致，无需进行特殊处理
2. 便于空表和非空表的统一处理
   - 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了

### 2.单链表结点的定义：

- ```c
  typedef struct Lnode
  {
      ElemType data; //结点的数据域
      struct Lnode *next; //结点的指针域
  }Lnode,*LinkList; //LinkList为指向结构体Lnode的指针类型
  //定义一个结构体类型指针的两种方式
  Lnode *p;
  LinkList L;
  //一般区分使用:
  //定义链表L
  LinkList L;
  //定义结点指针p:
  Lnode *p;
  ```

### 3.单链表结构的定义和表示

- eg：存储学生学号、姓名、成绩的单链表结点类型定义

  - 方式a：不常用，因为存在多个数据域

    - ```c
      typedef struct student
      {
          char num[8];//学号
          char name[8];//姓名
          int score;//成绩
          struct student *next; //指针域
      }Lnode,*LinkList;
      LinkList L;
      ```
  - 方式b：常用，将多个数据的内容先定义成一个结构体
  
    - ```c
      typedef struct
      {
          char num[8];//学号
          char name[8];//姓名
          int score;//成绩
      }ElemType;
      
      typedef struct Lnode
      {
          ElemType data;
          struct Lnode *next;
      }Lnode,*LinkList;
      ```

### 4.单链表基本操作的类C语言实现

#### 算法1：单链表的初始化 √

- 类C代码：

  - ```c
    /*算法步骤：
    1.生成新节点作为头结点，用头指针L指向头结点
    2.将头结点的指针域置空
    */
    Status InitList_L(LinkList &L)
    {
        L=(LinkList)malloc(sizeof(Lnode));
        L->next=NULL;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status InitList(LinkList *L)   //等价于Node **L  
    {   
        *L=(LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */  
        if(!(*L)) /* 存储分配失败 */  
                return ERROR;  
        (*L)->next=NULL; /* 指针域为空 */  
      
        return OK;  
    } 
    ```

  - **使用二级指针**
  
    - 因为要修改头指针的指向，即改变指针中存的地址数据（相当于改变一个int类型存放的数据时要传递int类型的指针；而要改变指针类型的数据，需要传递一个指针类型的指针，即二级指针），若参数传递的是头指针而不是头指针的地址，则在函数调用后头指针的内容即头指针的指向仍然是最开始的那个垃圾值，并没有指向我们为其动态分配的空间。（**二级指针的理解**）
  

#### 算法2：判断链表是否为空	√

- 类C代码

    - ```c
      //空表：链表中无元素，但头指针和头结点仍存在
      //算法思路：判断头结点指针域是否为空
      int ListEmpty(LinkList L) //若为空返回1，否则返回0
      {
          if(L->next == NULL)	//头结点的next域为空
              return 1;
          else			
              return 0;
      }
      ```

- C语言实现

    - ```c
        int IsEmptyLinkList(const LinkList* L)//常量指针，不可以通过*L改变L
        {
        	if ((*L)->next == NULL)
        		return 1;
        	else
        		return 0;
        }
        ```

    - ```c
        int Empty(LinkList L)
        {
        
        	if (L->next == NULL)
        		return 1;
        	return 0;
        }
        ```

#### 算法3：单链表的销毁，销毁后不存在	√

- 类C代码：

    - ```c
      //算法思路：从头指针开始，依次释放所有结点
      Status DestroyList_L(LinkList &L)
      {
          Lnode *p;
          while(L)
          {
              p=L;	//p指向头结点，从头结点开始释放
              L=L->next;	//头指针开始移动
              free(p);
          }
          return OK;
      }
      ```

- C语言实现：

  - ```c
    Status DestoryList_L(LinkList *L)
    {
    	LNode* p = *L;	//p此时指向头结点
    	//注意此时不能直接释放p，因为头结点中还存放着下一结点的地址，释放就找不到下一个结点了
    	while (*L)
    	{
    		*L = (*L)->next;
    		free(p); //第一次释放即释放掉头结点
    		p = *L;
    	}
    	return OK;
    }
    ```

#### 算法4：清空单链表	√

- 类C代码：

    - ```c
      //依次释放所有结点，并将头结点指针域设置为空
      Status ClearList_L(LinkList &L)
      {
          Lnode *p,*q;
          //p用于指向需要释放的结点，q用于在p释放之前指向下一结点，以使p移动	
      	//与销毁不同的是：清空时头指针L不能移动，销毁时L要销毁且移动，所以清空时要多设一个指针
          p=L->next;	//p指向首元结点
          while(p)
          {
         	 	q=p->next;	//q指向下一结点，保存将要释放结点的next域
          	free(p);
              p=q;
          }
          L->next=NULL;	//结点释放后还需要将头结点的指针域更改为NULL，形成空表
          return 0;
      }
      ```

- C语言实现：

  - ```c
    Status ClearLinkList(LinkList* L)
    {
    	LNode* p, * q;
    	q = (*L)->next;
    	while (q)
    	{
    		p = q;
    		q = q->next;
    		free(p);
    	}
    	(*L)->next = NULL;
    	return OK;
    }
    ```

  - ```c
    Status ClearList_L(LinkList L)//不需要改变头指针的指向，所以可以不使用二级指针
    {
    	LNode *p, *q;	//p用于指向需要释放的结点，q用于在p释放之前指向下一结点，以使p移动
    	p = L->next;	//p指向首元结点
    	while (p)
    	{
    		q = p->next;   //q指向下一结点
    		free(p);
    		p = q;
    	}
    	L->next = NULL;	//结点释放后还需要将头结点的指针域更改为NULL，形成空表
    	return OK;
    }
    ```

#### 算法5：求单链表表长

- 类C代码：

    - ```c
      //算法思路：从首元结点开始，依次计数所有结点
      int ListLength_L(LinkList L)
      {
          Lnode* p =L->next;//p指向第一个结点    
          i=0;
          while(p)
          {
              i++;
              p->next;
          }
          return i;
      }
      ```
    
- C语言代码：

  - ```c
    int LenLinkList(const LinkList* L)
    {
    	LNode* p = (*L)->next;
    	int i = 0;
    	while (p)
    	{
    		i++;
    		p = p->next;
    	}
    	(*L)->data = i;//将长度存储到L头结点的数据域中
    	return i;
    }
    ```
    
  - ```c
    int ListLength_L(LinkList L)
    {
    	LNode *p = L->next; //指向首元结点   后续移动用于指向除头结点以外的结点
    	int count = 0;
    	while (p)	//当所指结点不为空时，count++，并向后移一位
    	{
    		count++;
    		p = p->next;
    	}
        L->data = count;//将长度存储到L头结点的数据域中
    	return count;
    }
    ```

#### 算法6：取第i个元素的值	√

  - 按位查找：

    - 类C代码：

      - ```c
        Status GetElem_L(LinkList L,int i,ElemType &e)
        {
            p=L-next;  //p指向首元结点
            j=1;
            while(p&&j<i) //向后扫描直到p指向第i个元素或p为空
            {
                p=p->next;
                ++j;
            }
            if(!p||j>i)
                return ERROR; //第i个元素不存在
            e=p->data;
            return OK;
        }
        ```

    - C语言代码：

      - ```c
        Status LocateElem(const LinkList *L, int i, ElemType *e)
        {
        	LNode* p = (*L)->next;
            int j = 1;
        	while (p && j < i)
        	{
        		j++;
        		p = p->next;
        	}
        	if (!p || j > i)		//如果待查找的元素大于链表长度或者小于1，查找错误
        		return ERROR;
        	*e = p->data;
        	return OK;
        }
        ```

      - ```c
        Status GetElem(LinkList L, int i, ElemType *e)
        {
        	LNode *p = L->next;	//指向首元结点
        	int j = 1;
        	while (p && j<i) //向后扫描直到p指向第i个元素(j=i)（即找到了），或p为空（遍历完没找到）
        	{
        		p = p->next;
        		++j;
        	}
        	if (!p || j>i) //j大于i的情况：如i传入的为0或负数
        		return ERROR;
        	*e = p->data;
        	return OK;
        }
        ```

  - 按值查找：根据指定数据获取该数据所在的位置(地址或序号)   √

    - 返回地址

      - 类C代码：
    
        - 
          ```c
          Lnode *LocateElem_L(LinkList L,ElemType e)
          {
              p=L->next;
              while(p&&p->data!=e)
              {
                  p=p->next;
              }
              return p;
          }
          ```

      - C语言实现：
    
        - ```c
          LNode* LocateElem_V_LNode(const LinkList *L, ElemType e)
          {
          	LNode* p = (*L)->next;
          	while (p && p->data != e)		//p不为空指针，并且没找到
          	{
          		p = p->next;
          	}
          	return p;			//找到返回结点的地址，没找到返回NULL
          }
          ```
    
        - ```c
          LNode* LocateElem_Ad(LinkList L, ElemType e) //返回值为结构体类型的指针
          {
          	LNode *p = L->next;
          	while (p && p->data != e)	//向后扫描直到(p -> data == e)（即找到了），或p为空（遍历完没找到）
          	{
          		p = p->next;
          	}
          	return p;
          }
          ```
    
    - 返回序号
    
      - 类C代码：
    
        - ```c
          int LocateElem_L(LinkList L,ElemType e)
          {
              p=L->next;
              j=1;
              while(p&&p->data!=e)
              {
                  p=p->next;
                  j++;
              }//如果没找到，则p为空
              if(p)
                  return j;
              return 0;//查找失败返回0
          }
          ```
    
      - C语言实现：
    
        - ```c
          int LocateElem_V_Index(const LinkList *L, ElemType e)
          {
          	LNode* p = (*L)->next;
              int j = 1;
          	while (p && p->data != e)
          	{
          		j++;
          		p = p->next;
          	}
          	if (!p)
          		return 0;		//没找到,返回0
          	else
          		return j;		//找到,返回第几个结点
          }
          ```
    
        - ```c
          int LocateElem_Num(LinkList L, ElemType e)
          {
          	LNode *p = L->next;
          	int j = 1;
          	while (p && p->data != e)	//向后扫描直到(p -> data == e)（即找到了），或p为空（遍历完没找到）
          	{
          		p = p->next;
          		j++;
          	}//如果没找到，则p为空
          	if (p)
          		return j;
          	return 0;//查找失败返回0
          }
          ```

#### 算法7：插入结点（在第i个结点前插入值为e的新结点）√

- 类C代码：

    - ```c
      Status ListInsert_L(LinkList &L,int i,ElemType e)
      {
          p=L;
          j=0;
          while(p && j<i-1) //寻找第i-1个结点，p指向i-1结点
          {
              p=p->next;
              j++;
          }
          if(!p||j>i-1)
              return ERROR;  //i大于表长+1或小于1，插入位置非法
          s=(*Lnode)malloc(sizeof(Lnode));    //新建一个s结点（可能有问题）
          s->data=e; //生成新结点，将结点的数据域置为e
          s->next=p->next;
          p->next=s; //顺序不可颠倒
          return OK;
      }
      ```

- C语言实现：

  - ```c
    Status InsertLinkList(LinkList *L, int i, ElemType e)
    {
    	LNode* p = (*L);
    	int j = 0;
    	while (p && j < i - 1)		//找到第i-1个结点
    	{
    		j++;
    		p = p->next;
    	}
    	if (!p || j > i - 1)		//i大于表长+1,或者小于1,插入位置非法
    		return ERROR;
    	LNode* newlnode = (LNode*)malloc(sizeof(LNode));
    	newlnode->data = e;
    	newlnode->next = p->next;
    	p->next = newlnode;
    	return OK;
    }
    ```
    
  - ```c++
    Status ListInsert_L(LinkList L, int i, ElemType e)
    {
    	int j = 0;
    	LNode *p, *s;	//p用于循环遍历，s为新插入的结点
    	p = L; //指向头结点	
    	while (p && j<i - 1) //寻找第i-1个结点，p指向i-1结点	//循环结束后希望的结果是 j = i-1 
    	{
    		p = p->next;
    		j++;
    	}	
    	if (!p || j>i - 1)	//!p 循环遍历结束，p指向空时还未找到（即i的值过大）
    		return ERROR;  //j > i-1	i大于表长+1或小于1（i<=0），插入位置非法
    	s = (LNode*)malloc(sizeof(LNode));    //新建一个s结点，要插入的结点
    	s->data = e; //生成新结点，将结点的数据域置为e
    	s->next = p->next;
    	p->next = s; //顺序不可颠倒
    	return OK;
    }
    ```

#### 算法8：删除第i个结点（删除第i个元素）√

- 类C代码：

    - ```c
      Status ListDelete_L(LinkList &L,int i,ElemType &e)
      {
          p=L; //指向头结点
          j=0; 
          while(p->next&&j<i-1) //寻找第i-1个结点，且第i个结点不能为空
          {
              p=p->next;
              j++;
          }
          if(!(p->next)||j>i-1)
              return ERROR;
          q=p->next; //临时保存被删结点的地址以备释放
          p->next=p->next->next;	//令要释放结点的前驱结点的next域直接指向释放结点的后继结点
          e=q->data; //存放删除结点的数据
          free(q);//释放删除结点的空间
          return OK;
      }
      ```

- C语言代码：

  - ```c
    //将删除值返回
    Status ListDelete_L(LinkList L, int i, ElemType *e)
    {
    	LNode *p = L; //指向头结点
    	LNode *q;
    	int j = 0;
    	while (p->next && j<i - 1) //寻找第i-1个结点，且第i个结点不能为空
    	{
    		p = p->next;
    		j++;
    	}
    	if (!(p->next) || j>i - 1) //要删除结点不存在
    		return ERROR;
    	q = p->next; //临时保存被删结点的地址以备释放
    	p->next = q->next;	//令要释放结点的前驱结点的next域直接指向释放结点的后继结点
    	*e = q->data; //存放删除结点的数据
    	free(q);	//释放删除结点的空间
    	return OK;
    }
    ```

  - ```c
    //不返回删除值
    Status DeleteLinkList(LinkList *L, int i)
    {
    	LNode* p, * q;
    	int j = 1;
    	p = (*L)->next;
    	while (p && j < i - 1)
    	{
    		j++;
    		p = p->next;
    	}
    	if (!p || j > i - 1)
    		return ERROR;
    	q = p->next;
    	p->next = q->next;
    	free(q);
    	return OK;
    }
    ```

#### 算法9：头插法建立单链表	√

- 类C代码：

    - ```c
      void CreateList_H(LinkList &L,int n) //n 为插入的元素个数
      {
          L=(*Lnode)malloc(sizeof(Lnode)); //头结点
          L->next=NULL;
          for(i=n;i>0;i--)
          {
              p=(*Lnode)malloc(sizeof(Lnode)); //新结点
              //输入元素，存在p->data;
              p->next=L->next;
              L->next=p;
          }
      } //时间复杂度O(n)
      ```

- C语言实现：

  - ```c
    void CreateLinkList_H(LinkList* L, int n)
    {
    	*L = (LinkList)malloc(sizeof(LNode));
    	(*L)->next = NULL;					//先建立一个头结点
    	int i;
    	for (i = n; i > 0; i--)
    	{
    		LNode* newlnode;
    		newlnode = (LNode*)malloc(sizeof(LNode));
    		printf("Enter the node data:_____\b");
    		scanf("%d", &newlnode->data);
    		newlnode->next = (*L)->next;
    		(*L)->next = newlnode;
    	}
    }
    ```

  - ```c
    Status CreateList_H(LinkList *L, int n)
    {
    	LNode *p, *r;  //p用于指向新结点,r指向头结点
    	//建立一个带有头结点的单链表并将指针域置为空
    	*L = (LinkList)malloc(sizeof(LNode));
    	r = *L;
    	r->next = NULL;
    	//结点添加与赋值
    	for (int i = n; i>0; i--) {
    		p = (LNode *)malloc(sizeof(LNode)); //为新结点动态分配内存
    		p->next = NULL;
    		printf("请输入该链表的第%d个元素：", i);
    		scanf("%d", &p->data);
    		p->next = r->next;	
    		r->next = p;
    	}
    	return OK;
    }
    ```

#### 算法10：尾插法建立单链表	√

- 类C代码：

    - ```c
      /*
      1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表尾部
      2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点
      */
      void CreateList_R(LinkList &L,int n)
      {
          L=(*Lnode)malloc(sizeof(Lnode)); //头结点
          L->next=NULL;
          r=L; //尾指针指向头结点
          for(i=0;i<n;i++)
          {
              p=(*Lnode)malloc(sizeof(Lnode)); //新结点
              //输入元素，存在p->data;
              p->next=NULL;
              r->next=p;
              r=p; //尾指针指向新的尾结点
          }
      } //时间复杂度O(n)
      ```

- C语言实现：

  - ```c
    void CreateLinkList_R(LinkList *L, int n)
    {
    	*L = (LinkList)malloc(sizeof(LNode));
    	(*L)->next = NULL;//先建立一个头结点
    	LNode* p;
    	p = *L;
    	int i;
    	for (i = n; i > 0; i--)
    	{
    		LNode* newlnode = (LNode*)malloc(sizeof(LNode));
    		printf("Enter the node data:___\b");
    		scanf("%d", &newlnode->data);
    		newlnode->next = NULL;
    		p->next = newlnode;
    		p = p->next;
    	}
    }
    ```

  - ```c
    Status CreateList_R(LinkList *L, int n)
    {
    	LNode *p, *r;//p用于指向新结点(待插入结点)，r指向尾部结点
    	*L = (LinkList)malloc(sizeof(LNode));
    	r = *L;  //刚开始时r指向头结点
    	r->next = NULL;
    	for (int i = 1; i <= n; i++) {
    		p = (LNode *)malloc(sizeof(LNode));   //注意这里不要忘记将这块内存定义为Node的指针类型
    		printf("请输入该链表的第%d个元素：", i);
    		scanf("%d", &p->data);
    		p->next = NULL;	//新结点的next域为空
    		r->next = p;
    		r = r->next;	//尾指针指向新的尾接点
    	}
    	return OK;
    }
    ```

#### 算法11：显示单链表	√

- C语言实现：

  - ```c
    void ShowLinkList(const LinkList* L)
    {
    	LNode* p = (*L)->next;//指向首元结点
    	if (!p)//首元结点为空
    	{
    		puts("The LinkList is empty");
    		return;
    	}
    	int i = 1;
    	while (p)
    	{
    		printf("%d : %d\n", i, p->data);
    		i++;
    		p = p->next;
    	}
    	putchar('\n');
    }
    ```
    
  - ```c
    Status ListTraverse(LinkList L) 
    {
    	LNode* p = L->next;
    	printf("链表中所有元素为： ");
    	if (!p)
    	{
    		printf("此时链表为空\n");
    		return ERROR;//如果首元结点不存在返回0
    	}		
    	while (p) {
    		printf("%d ", p->data);
    		p = p->next;
    	}
    	printf("\n");
    	return OK;
    }
    ```

#### 单链表完整代码演示

- ```c
  #define _CRT_SECURE_NO_WARNINGS 1
  
  #include<stdio.h>
  #include<stdlib.h>
  
  #define OK 1	//成功标志
  #define  ERROR 0	//失败标志
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int ElemType;	//ElemType的类型根据实际情况而定，这里假定为int
  
  typedef struct LNode	//定义单链表结点类型
  { 
  	ElemType data; //数据域
  	struct LNode *next; //指针域
  }LNode, *LinkList;	//LNode:结构体类型;*LinkList:指向LNode类型的指针
  
  //函数声明
  Status InitList_L(LinkList *L);	//单链表的初始化
  Status ListInsert_L(LinkList L, int i, ElemType e);	//单链表的插入
  int Empty(LinkList L);	//判断单链表是否为空
  Status DestoryList_L(LinkList *L);	//销毁单链表
  Status ClearList_L(LinkList L);	//单链表的清空
  int ListLength_L(LinkList L);	//求单链表的表长
  Status GetElem(LinkList L, int i, ElemType *e);	//单链表的取值->按位查找
  LNode *LocateElem_Ad(LinkList L, ElemType e);	//单链表的查找->按值查找->返回地址
  int LocateElem_Num(LinkList L, ElemType e);	//单链表的查找->按值查找->返回序号
  Status ListDelete_L(LinkList L, int i, ElemType *e);	//单链表结点的删除
  Status CreateList_H(LinkList *L, int n);	//单链表的创建（头插法）
  Status CreateList_R(LinkList *L, int n);	//单链表的创建（尾插法）
  Status ListTraverse(LinkList L);	//遍历打印链表
  
  int main()
  {
  	LinkList L = NULL;
  
  	int a = 0;//a用于判断函数是否执行成功
  	int n = 0;//n表示要插入链表的元素个数
  	int i = 0;//i表示要操作元素的位置
  	int e = 0;//e表示要操作元素的内容
  	int m = 0;//m表示查找元素的序号
  	int f = 1;	//用于跳出循环
  	int select = 0;	//用于用户输入选择
  	int length = 0;
  
  	while (f)
  	{
  		printf("---------------------------------------------------------------------------\n");
  		printf("请选择要进行的操作：\n");
  		printf("1.头插法建立链表	2.尾插法建立链表	3.单链表的插入	4.单链表的删除	5.单链表的取值\n");
  		printf("6.查找返回地址		7.查找返回序号		8.单链表的清空	9.判断单链表是否为空\n");
  		printf("10.求单链表表长		11.销毁单链表		12.退出		13.单链表的初始化\n");
  
  		scanf("%d", &select);
  		switch (select)
  		{
  		case 1:
  		{
  				  //头插法创建链表
  				  printf("请输入头插法创建链表的元素个数：");
  				  scanf("%d", &n);
  				  CreateList_H(&L, n);
  				  ListTraverse(L);
  				  break;
  		}		
  		case 2:
  		{
  				  //尾插法创建链表
  				  printf("请输入头插法创建链表的元素个数：");
  				  scanf("%d", &n);
  				  CreateList_R(&L, n);
  				  ListTraverse(L);
  				  break;
  		}		
  		case 3:
  		{
  				  printf("请输入要插入的位置 i 及插入元素的值 e ：");
  				  scanf("%d %d", &i, &e);
  				  ListInsert_L(L, i,  e);
  				  ListTraverse(L);
  				  break;
  		}
  		case 4:
  		{
  				  printf("请输入要删除的元素序号 i ：");
  				  scanf("%d", &i);
  				  ListDelete_L(L, i, &e);
  				  printf("删除掉的第 %d 位元素的 值为 %d\n", i, e);
  				  ListTraverse(L);
  				  break;
  		}
  		case 5:
  		{
  				  printf("查找链表中第i个元素的值，请输入i的值：");
  				  scanf("%d", &i);
  				  GetElem(L, i, &e);
  				  printf("第%d位元素的值为%d\n", i, e);
  				  break;
  		}
  		case 6:
  		{
  				  printf("查找链表中值为e的元素的地址，请输入e的值：");
  				  scanf("%d", &e);			  
  				  printf("第一个值为%d的元素的地址为%p\n", e, LocateElem_Ad(L,e));
  				  break;
  		}	
  		case 7:
  		{
  				  printf("查找链表中值为e的元素的序号（用m返回），请输入e的值：");
  				  scanf("%d", &e);
  				  m = LocateElem_Num(L, e);
  				  printf("第一个值为%d的元素的序号为%d\n", e, m);
  				  break;
  		}			
  		case 8:
  		{
  				  a = ClearList_L(L);	//清空单链表
  				  if (a = 1)
  					  printf("清空单链表成功\n");
  				  ListTraverse(L);
  				  break;
  		}
  		case 9:
  		{
  				  a = Empty(L);
  				  if (a == 1)
  					  printf("单链表为空！\n");
  				  else
  					  printf("单链表不为空！\n");
  				  break;
  		}
  		case 10:
  		{
  				   length = ListLength_L(L);
  				   printf("单链表表长为：%d\n", length);
  				   break;
  		}
  		case 11:
  		{
  				   DestoryList_L(&L);
  				   break;
  		}
  		case 12:
  			f = 0;
  			break;
  		case 13:
  			InitList_L(&L);
  			break;
  		default:
  			printf("输入错误，请重新输入！/n");
  			break;
  		}
  	}
  	return 0;
  }
  
  //函数定义：
  
  //单链表的初始化，构建一个带头结点的单链表（要用二级指针）
  Status InitList_L(LinkList *L)
  {
  	*L = (LinkList)malloc(sizeof(LNode)); //生成头结点，并使L指向头结点
  	if (!(*L)) // 存储分配失败 
  		return ERROR;
  	(*L)->next = NULL;
  	return 0;
  }
  
  //单链表的插入
  /*
  初始条件:单链表L已经存在
  操作结果，在L中第i个位置之前插入新的数据元素e
  */
  Status ListInsert_L(LinkList L, int i, ElemType e)
  {
  	int j = 0;
  	LNode *p, *s;	//p用于循环遍历，s为新插入的结点
  	p = L; //指向头结点	
  	while (p && j<i - 1) //寻找第i-1个结点，p指向i-1结点	//循环结束后希望的结果是 j = i-1 
  	{
  		p = p->next;
  		j++;
  	}	
  	if (!p || j>i - 1)	//!p 循环遍历结束，p指向空时还未找到（即i的值过大）
  		return ERROR;  //j > i-1	i大于表长+1或小于1（i<=0），插入位置非法
  	s = (LNode*)malloc(sizeof(LNode));    //新建一个s结点，要插入的结点
  	s->data = e; //生成新结点，将结点的数据域置为e
  	s->next = p->next;
  	p->next = s; //顺序不可颠倒
  	return OK;
  }
  
  //判断单链表是否为空
  /*若为空返回1，否则返回0*/
  int Empty(LinkList L)
  {
  
  	if (L->next == NULL)	//头结点的next域为空
  		return 1;
  	return 0;
  }
  
  //销毁单链表（使用二级指针）
  /*将链表中所有结点包括头结点都释放掉*/
  Status DestoryList_L(LinkList *L)
  {
  	LNode* p = *L;	//p此时指向头结点
  	//注意此时不能直接释放p，因为头结点中还存放着下一结点的地址，释放就找不到下一个结点了
  	while (*L)
  	{
  		*L = (*L)->next;
  		free(p); //第一次释放即释放掉头结点
  		p = *L;
  	}
  	return OK;
  }
  
  //单链表的清空
  /*依次释放所有结点，并将头结点指针域设置为空*/
  Status ClearList_L(LinkList L)
  {
  	LNode *p, *q;	//p用于指向需要释放的结点，q用于在p释放之前指向下一结点，以使p移动	
  	//与销毁不同的是：清空时头指针L不能移动，销毁时L要销毁且移动，所以清空时要多设一个指针
  	p = L->next;	//p指向首元结点
  	while (p)
  	{
  		q = p->next;   //q指向下一结点，保存将要释放结点的next域
  		free(p);
  		p = q;
  	}
  	L->next = NULL;	//结点释放后还需要将头结点的指针域更改为NULL，形成空表
  	return OK;
  }
  
  //求单链表的表长
  int ListLength_L(LinkList L)
  {
  	LNode *p;   //用于指向除头结点以外的结点
  	int count = 0;
  	p = L->next; //指向首元结点
  	while (p)	//当所指结点不为空时，count++，并向后移一位
  	{
  		count++;
  		p = p->next;
  	}
  	return count;
  }
  
  //单链表的取值（也即按位查找）
  /*按位查找：返回链表中第i位置的元素*/
  Status GetElem(LinkList L, int i, ElemType *e)
  {
  	LNode *p = L->next;	//指向首元结点
  	int j = 1;
  	while (p && j<i) //向后扫描直到p指向第i个元素(j=i)（即找到了），或p为空（遍历完没找到）
  	{
  		p = p->next;
  		++j;
  	}
  	if (!p || j>i) //j大于i的情况：如i传入的为0或负数
  		return ERROR;
  	*e = p->data;
  	return OK;
  }
  
  //单链表的查找（也即按值查找）
  /*按值查找：根据指定数据获取第一个该数据所在的位置(地址或序号)*/
  
  //返回地址:
  LNode *LocateElem_Ad(LinkList L, ElemType e) //返回值为结构体类型的指针
  {
  	LNode *p = L->next;
  	while (p && p->data != e)	//向后扫描直到(p -> data == e)（即找到了），或p为空（遍历完没找到）
  	{
  		p = p->next;
  	}
  	return p;
  }
  //返回序号
  int LocateElem_Num(LinkList L, ElemType e)
  {
  	LNode *p = L->next;
  	int j = 1;
  	while (p && (p->data != e))	//向后扫描直到(p -> data == e)（即找到了），或p为空（遍历完没找到）
  	{
  		p = p->next;
  		j++;
  	}//如果没找到，则p为空
  	if (p)
  		return j;	//p不为空，返回j
  	return 0;//查找失败返回0
  }
  
  //单链表结点的删除（并用e返回被删结点的元素内容）
  Status ListDelete_L(LinkList L, int i, ElemType *e)
  {
  	LNode *p = L; //指向头结点
  	LNode *q;
  	int j = 0;
  	//寻找第i-1个结点，且第i个结点不能为空 
  	//结束循环时（j = i-1),即p指向被删元素的前一个结点（即找到了）
  	//或p->next == NULL 此时p已经为最后一个结点（没找到）
  	while (p->next && j<i - 1) 
  	{
  		p = p->next;
  		j++;
  	}
  	if (!(p->next) || j>i - 1) //p->next == NULL，或i <= 0 //代表要删除结点不存在
  		return ERROR;
  	q = p->next; //临时保存被删结点的地址以备释放
  	p->next = p->next->next;	//令要释放结点的前驱结点的next域直接指向释放结点的后继结点
  	*e = q->data; //存放删除结点的数据
  	free(q);	//释放删除结点的空间
  	return OK;
  }
  
  //单链表的创建（头插法和尾插法）
  /*头插法:输入n个元素 ，元素从头开始依次插入	,即新元素永远插入在头结点后、首元结点前（相当于同时完成了单链表的初始化和单链表的插入）*/
  Status CreateList_H(LinkList *L, int n)
  {
  	LNode *p, *r;  //p用于指向新结点,r指向头结点之后循环遍历
  	//建立一个带有头结点的单链表并将指针域置为空
  	*L = (LinkList)malloc(sizeof(LNode));
  	r = *L;
  	r->next = NULL;	//头结点的next域为空，完成初始化
  	//结点添加与赋值
  	for (int i = n; i>0; i--)
  	{
  		p = (LNode *)malloc(sizeof(LNode)); //为新结点动态分配内存
  		p->next = NULL;
  		printf("请输入该链表的第%d个元素：", i);
  		scanf("%d", &p->data);
  		p->next = r->next;
  		r->next = p;
  	}
  	return OK;
  
  }
  
  //尾插法
  /*尾插法创建链表：输入n个元素， 元素从尾部依次接入*/
  Status CreateList_R(LinkList *L, int n)
  {
  
  	LNode *p, *r;//p用于指向新结点(待插入结点)，r指向尾部结点
  	*L = (LinkList)malloc(sizeof(LNode));
  	r = *L;  //刚开始时r指向头结点
  	r->next = NULL;
  	for (int i = 1; i <= n; i++) {
  		p = (LNode *)malloc(sizeof(LNode));   //注意这里不要忘记将这块内存定义为Node的指针类型
  		printf("请输入该链表的第%d个元素：", i);
  		scanf("%d", &p->data);
  		p->next = NULL;	//新结点的next域为空
  		r->next = p;
  		r = r->next;	//尾指针指向新的尾接点
  	}
  	return OK;
  }
  
  //遍历打印链表
  Status ListTraverse(LinkList L) 
  {
  	LNode* p = L->next;	//指向首元结点
  	printf("链表中所有元素为： ");
  	if (!p)
  	{
  		printf("此时链表为空\n");
  		return ERROR;//如果首元结点不存在返回0
  	}		
  	while (p) 
  	{
  		printf("%d ", p->data);
  		p = p->next;
  	}
  	printf("\n");
  	return OK;
  }
  
  ```

### 5.循环链表：

- 循环链表：头尾相接的链表（最后一个结点的指针域指向头结点，整个链表形成一个环）
- 优点：从表中任一结点出发均可找到表中其他结点
- 注意：循环链表中没有NULL指针，故涉及遍历操作时，终止条件为是否等于头指针
- eg：带**尾指针**循环链表的合并（尾指针Ta和Tb）

    - 操作步骤：

        1. p存Ta的表头结点：`p=Ta->next	//因为要改变Ta->next，且后面要使用到Ta的表头结点，所以需要先存起来`
        2. Tb表头连接到Ta表尾：`Ta->next=Tb->next->next //Tb->next是Tb的头结点，Tb->next->next是Tb的首元结点`
        3. 释放Tb表头结点：`free(Tb-next)`
        4. Tb指向Ta的头结点：`Tb->next=p`

    - ```c
        LinkList Connect(LinkList Ta,LinkList Tb)
        {
            p=Ta->next;
            Ta->next=Tb->next->next;
            free(Tb-next);
            Tb->next=p;
            return Tb;
        }
        ```

### 6.双向链表：

- 在单链表的每个结点里再增加一个指向其直接前驱的指针域prior

- 双向链表的结构定义：

    - ```c
        typedef struct DuLnode
        {
            ElemType data;
            struct DuLnode *prior;
            struct DuLnode *next;
        }DuLnode,*DuLinkList;
        ```

- 双向链表的对称性：

    - `p->prior->next = p = p->next->prior`

- 双向链表中，插入、删除操作需要同时修改两个方向上的指针

    - 双向链表的插入操作：

        - ```c
            void ListInsert_DuL(DuLinkList &L, int i, ElemType e) //在带头结点的双向链表L的第i个位置前插入元素e
            {
                if(!(p=GetElemP_DuL(L,i))) //找到第i个元素
                    return ERROR;
                s=(*DuLnode)malloc(sizeof(DuLnode));
                s->data=e;
                s->prior=p->prior; //将新结点的前驱改为p的前驱
                p->prior->next=s; //将p的前驱的后继改为新结点
                p->prior=s; //p的前驱改为新结点s
                s->next=p; //新结点s的后继改为p
            }
            ```

    - 双向链表的删除：

        - ```c
            void ListDelete_DuL(DuLinkList &L, int i, ElemType &e) //删除第i个元素，并用e返回
            {
                if(!(p=GetElemP_DuL(L,i))) //找到第i个元素
                    return ERROR;
                e=p->data;
                p->prior->next=p->next; //p的前驱的后继改为p的后继
                p->next->prior=p->prior; //p的后继的前驱改为p的前驱
                free(p);
            }
            ```

### 7.单链表、循环链表和双向链表的时间效率比较

- |                                 |         查找首元结点         |             查找表尾结点              |            查找结点*p的前驱结点            |
    | ------------------------------- | :--------------------------: | :-----------------------------------: | :----------------------------------------: |
    | 带头结点的单链表L               |    L->next 时间复杂度O(1)    | 从L->next依次向后遍历，时间复杂度O(n) |          通过p->next无法找到前驱           |
    | 带头结点仅设头指针L的循环单链表 |    L->next 时间复杂度O(1)    | 从L->next依次向后遍历，时间复杂度O(n) |  通过p->next可以找到前驱，时间复杂度O(n)   |
    | 带头结点仅设尾指针R的循环单链表 | R->next->next 时间复杂度O(1) |           R，时间复杂度O(1)           |  通过p->next可以找到前驱，时间复杂度O(n)   |
    | 带头指针的双向循环链表L         |    L->next 时间复杂度O(1)    |       L->prior，时间复杂度O(1)        | p->prior，时间复杂度O(1)顺序表和链表的比较 |

### 8.常见问题：

1. 为什么单链表初始化时用二级指针，而插入操作时用一级指针？

   - 在初始化过程中，需要修改头指针，因此要用到二级指针传递头指针的地址，这样才能修改头指针。这与普通变量类似，当需要修改普通变量的值，需传递其地址。使用二级指针，很方便就修改了传入的结点一级指针的值。 如果用一级指针，则只能通过指针修改指针所指内容，却无法修改指针的值，也就是指针所指的内存块。
   - 在使用带头结点的单链表时：
     1. 初始化链表头部指针需要用二级指针
     2. 销毁链表需要用到二级指针
     3. 插入、删除、遍历、清空结点用一级指针即可
     4. 头插法和尾插法建立链表也需要使用二级指针，因为其相当于初始化和插入的合并
   - 注意：
     - 如果是不带头结点的单链表，插入、删除和清空结点也需要二级指针（比如往空链表中插入一个节点时，新插入的节点就是链表的头指针，此时会改动头指针。同理，删除第一个结点和清空结点都会改动头指针）。

## （六）顺序表的链表的比较

- 链式存储结构：
  - 优点：
    - 节点空间可以动态申请和释放
    - 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素
  - 缺点：
    - 存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大（存储密度=结点数据所占空间/结点所占的空间总量）
    - 链式存储结构是非随机存取结构，对任意结点的操作都要从头指针依指针链查找到该结点
- 空间：
  - 存储空间：
    - 顺序表：预先分配，会导致空闲限制或溢出
    - 链表：动态分配，不会出现存储空间闲置或溢出
  - 存储密度：
    - 顺序表：不用为表示结点间的逻辑关系而额外增加存储开销，存储密度为1
    - 链表：需要借助指针来体现元素间的逻辑关系，存储密度小于1
- 时间：
  - 存取元素：
    - 顺序表：随机存取，按位置访问元素时间复杂度为O(1)
    - 链表：顺序存取，按位置访问元素时间复杂度为O(n)
  - 插入、删除：
    - 顺序表：平均移动表中一半元素，时间复杂度为O(n)
    - 链表：不需要移动元素，确定位置后，时间复杂度为O(1)
- 使用情况：
  - 顺序表：
    1. 表长变化不大，且能事先确定变化的范围
    2. 很少进行插入或删除的操作，经常按元素位置序号访问数据元素
  - 链表：
    1. 长度变化很大
    2. 频繁进行插入或删除操作 

## （七）线性表的应用

### 1.线性表的合并

- 算法步骤：

  - 依次取出Lb中的每个元素，执行以下操作：
    1. 在La中查找该元素
    2. 如果找不到，则将其插入到La的最后

- ```c
  void union(List &La,List Lb)//仅表示思路
  {
      La_len=ListLength(La);//求线性表La的长度
      Lb_len=ListLength(Lb);
      for(i=1;i<Lb_len;i++)//遍历Lb中元素
      {
          GetElem(Lb,i,e);
          if(!(LocateElem(La,e)))//执行条件为，在La中找不到元素e
              ListInsert(La,++La_len,e);//插入到第表长加一个位置
      }
  }
  ```

### 2.有序表的合并（顺序表）

- 已知线性表La和Lb中的数据元素非递减有序排列，现要求将两表归并为一个新的非递减有序排列
- 算法步骤：
  1. 创建一个空表c
  2. 依次从La和Lb中摘取元素值较小的结点插入到Lc表的最后，直至其中一个表为空
  3. 继续将没有空的那个表的剩余结点插入到Lc表的最后
  
- ```c
  void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
  {
      pa=LA.elem;
      pb=LA.elem;//指针pa、pb分别指向两个表的第一个元素
      LC.length=LA.length+LB.length;
      LC.elem=(*ElemType)malloc(LC.length*sizeof(Elemtype));
      pc=LC.elem;//
      pa_last=LA.elem+LA.length-1;//指向LA表最后一个元素，用来记录是否遍历到了表尾
      pb_last=LB.elem+LB.length-1;
      while(pa<=pa_last&&pb<=pb_last)//两表都不为空时
      {
          if(*pa<=*pb)
          {
              *pc=*pa;
              pc++;//指针右移
              pa++;
              //或直接写成：*pc++=*pa++;
          }
          else
          {
              *pc=*pb;
              pc++;//指针右移
              pb++;
              //或直接写成：*pc++=*pb++;
          }
          while(pa<=pa_last)//此时LB表已遍历完,将LA中剩余元素加入LC
              *pc++=*pa++;
          while(pb<=pb_last)//此时LA表已遍历完,将LB中剩余元素加入LC
              *pc++=*pb++;
      }
  }
  ```

### 3.有序表的合并（链表）

- ```c
  void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc)
  {
      pa=La->next;//pa指针指向La的首元结点
      pb=Lb->next;
      pc=Lc=La;
      while(pa && pb)//两表都不为空时
      {
          if(pa->data<pb->data)
          {
              pc->next=pa;//将pa接在pc之后
              pc=pa;//pc移动到pa
              pa=pa->next;//pa后移
          }
          else
          {
              pc->next=pb;
              pc=pb;
              pb=pb->next;
          }
      }
      pc->next=pa?pa:pb;//pa不为空则指向pa
      free(Lb);//释放Lb的头结点
  }
  ```

## （八）案例分析和实现

### 案例一：一元多项式的运算

- 实现两个多项式加、减、乘运算

### 案例二：稀疏多项式的运算

#### 顺序表实现

- 例如两个线性表：
  - 线性表`A = ((7,0),(3,1),(9,8),(5,17))`
  - 线性表`B=((8,1)(22,7),(-9,8))`

- 算法思路：

  1. 创建一个新数组c
  2. 分别从头遍历比较a和b的每一项
     - 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项
     - 指数不相同：则将较小项复制到c中
  3. 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可

- 问题分析：

  - 顺序存储结构存在问题：
    - 存储空间分配不灵活
    - 运算空间复杂度高

- 算法实现：

  - ```c
    ```

#### 链表实现

- 算法思路：

  1. 创建一个只有头结点的空链表
  2. 根据多项式的个数n，循环n次执行以下操作：
     1. 生成一个新结点s
     2. 输入多项式当前项的系数和指数赋值给新结点s的数据域
     3. 设置一个前驱指针pre，用于指向待找到的第一个大于输出项指数的结点的前驱，pre初值指向头结点
     4. 指针q初始化，指向首元结点
     5. 循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输出项的结点q
     6. 将输入项结点s插入到结点q之前

- 算法描述：

  - 多项式结点的定义：

    - ```c
      typedef struct PNode
      {
          float coef;//系数
          int expn;//指数
          struct PNode *next;//指针域
      }PNode,*polynomial;
      ```

  - 多项式创建：

    - ```c
      void Createpolyn(Polynomial &P,int n)
      {
          P=(*PNode)malloc(sizeof(PNode));//先建立一个带头结点的单链表
          P->next=NULL;
          for(i=1;i<=n;i++)
          {
              s=(*PNode)malloc(sizeof(PNode));//生成新结点
              //输入系数和指数
              pre=P;//pre用于保存q的前驱，初值为头结点
              q=P->next;//q指向首元结点
              while(q && q->expn<s->expn)
              {
                  pre=q;
                  q=q->next;
              }
              s->next=q;//将输入项s插入到q和其前驱结点pre之间
              pre->next=s;
          }
      }
      ```

  - 多项式相加：

    - 算法步骤：
      1. 指针p1和p2初始化，分别指向Pa和Pb的首元结点
      2. p3指向和多项式的当前节点，初值为Pa的头结点
      3. 当指针p1和p2均未到达相应表尾时，循环比较p1和p2所指结点对应的指数(p1->expn和p2->expn)，有三种情况
         1. 当p1->expn==p2->expn时，则将两个结点中的系数相加
            1. 若和不为零，则修改p1所对应的结点的系数值，同时删除p2所指结点
            2. 若和为零，则删除p1和p2所指结点
         2. 当p1->expn<p2->expn时，则摘取p1所指结点到“和多项式”链表中
         3. 当p1->expn>p2->expn时，则摘取p2所指结点到“和多项式”链表中
      4. 将非空多项式剩余段插入p3所指结点之后
      5. 释放Pb的头结点

### 案例三：图书信息管理

- 结构类型定义

  - ```c
    struct Book
    {
        char id[20];//ISBN
        char name[50];//书名
        int price;//定价
    }
    
    typedef struct
    {
        Book *elem;
        int length;
    }SqList;//顺序表定义
    
    typedef struct LNode
    {
        Book data;
        struct LNode *next;
    }LNode,*LinkList;//链表定义
    ```

# 三.栈和队列

## （一）栈和队列的定义和特点

- 栈和队列是限定插入和删除只能在表的端点进行的线性表
- 栈(stack)是一个特殊的线性表，是限定在一端进行插入和删除的线性表，后进先出(Last In First Out)，简称(LIFO)
  - 栈仅在表尾（栈顶）进行插入、删除
  - 表尾(an)称为栈顶（Top），表头(a1)称为（Base）
  - eg：栈 s=(a1,a2,......an);
  - 插入到栈顶称为入栈，从栈顶删除叫出栈

- 队列(queue)，是一种先进先出(First In First Out)的线性表(FIFO)，在表一端（表尾）插入，在另一端（表头）删除

### 1.栈的应用

- “先进后出，后进先出”

  - 数值转换

  - 表达式求值

  - 括号匹配的检验

  - 八皇后问题

  - 行编辑程序

  - 函数调用

  - 迷宫求解

  - 递归调用的实现

### 2.队列的应用

- “先进先出，后进后出”，类似排队问题
  - 脱机打印：按申请的先后顺序依次输出
  - 多用户系统中，多个用户排队，分别循环使用CPU和主存
  - 按用户的优先级排成队，每个优先级一个队列
  - 实时控制系统，信号按接收的先后顺序依次处理
  - 网络电文传输，按到达的时间先后顺序依次处理

## （二）案例引入

### 案例一：进制转换

### 案例二：括号匹配的检验

### 案例三：表达式求值

### 案例四：舞伴问题

## （三）栈的表示和实现

### 1.栈的抽象数据类型定义

- ```c
  ADT Stack{
      数据对象：
          D={ai|ai∈ElemSet，i=1,2,3,......,n,n>=0};
      数据关系
          R1={<ai-1,ai>|ai-1,ai∈D,i=2,...,n};
      基本操作：初始化、进栈、出栈、取栈顶元素等;
  }ADT Stack
  ```

### 2.栈的基本操作

1. InitStack(&S)
   - 栈的初始化
   - 操作结果：构造一个空栈S
2. DestroyStack(&S)
   - 栈的销毁
   - 初始条件：栈S已经存在
   - 操作结果：栈S被销毁
3. StackEmpty(S)
   - 判定栈S是否为空栈
   - 初始条件：栈S已经存在
   - 操作结果：若栈S为空栈，则返回TURE；否则返回FALSE
4. StackLength(S)
   - 求栈的长度
   - 初始条件：栈S已经存在
   - 操作结果：返回S的元素个数，即栈的长度
5. GetTop(S,&e)
   - 取栈顶元素
   - 初始条件：栈S已经存在，且非空
   - 操作结果：用e返回S的栈顶元素
6. ClearStack(&S)
   - 清空栈
   - 初始条件：栈S已经存在
   - 操作结果：将栈S清空
7. Push(&S,e)
   - 入栈
   - 初始条件：栈S已经存在
   - 操作结果：插入元素e为新的栈顶元素
8. Pop(&S,&e)
   - 出栈
   - 初始条件：栈S已经存在
   - 操作结果：删除栈顶元素an，并用e返回其值

### 3.顺序栈的表示和实现

#### （1）.存储方式：

- 同一般线性表的顺序存储结构完全相同

  - 利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，栈底一般在低地址处

  - 附设top指针，指示栈顶元素在顺序栈中的位置

  - 另设base指针，指示栈底元素在顺序栈中的位置

  - 但是为了方便操作，通常top指示真正的栈顶元素之上的下标地址

  - 另外，用stacksize表示栈可使用的最大容量

  - 空栈标志：top==base

  - 栈满标志：top-base==stacksize

    - 栈满时的处理方法：
      1. 报错，返回操作系统
      2. 分配更大空间作为栈的存储空间，将原栈的内容移入新栈

  - 上溢(overflow)：栈已满，还要压入元素

  - 下溢(underflow)：栈已空，还要弹出元素

  - 注意：上溢是一种错误，使问题无法继续执行；而下溢一般认为是一种结束条件，使问题处理结束

#### （2）.顺序栈的表示

  - ```c
    #define MAXSIZE 100
    typedef struct
    {
        SElemType *base;//栈底指针，也用来表示数组
        SElemType *top;//栈顶指针
        int stacksize;//栈可用最大容量
    }SqStack;
    ```

#### （3）.顺序栈的基本操作实现

##### 算法1：顺序栈的初始化 √

- 类C代码：

  - ```c
    Status InitStack(SqStack &S)
    {
        S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType));
        if(!S.base)
            exit(OVERFLOW);//存储分配失败
        S.top=S.base;//栈顶指针等于栈底指针
        S.stacksize=MAXSIZE;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status InitSqStack(SqStack* S)
    {
    	S->base = (SElemType*)malloc(MAXSIZE * sizeof(SElemType));
    	if (!S->base)			//S->base为NULL，开辟空间失败
    		exit(OVERFLOW);
    	S->top = S->base;
    	S->stacksize = MAXSIZE;
    	return OK;
    }
    ```

##### 算法2：顺序栈判断是否为空 √

- 类C代码：

  - ```c
    Status StackEmpty(SqStack S) //若栈为空，返回TURE;若不为空，返回FALSE
    {
        if(S.top == S.base)
            return TURE;
        return FALSE;
    }
    ```

- C语言实现：

  - ```c
    Status IsEmptySqStack(const SqStack* S)
    {
    	if (S->base == S->top)
    		return TRUE;
    	else
    		return FALSE;
    }
    ```
    
  - ```c
    Status IsEmptySqStack(SqStack S)
    {
    	if (S.base == S.top)
    		return TRUE;
    	else
    		return FALSE;
    }
    ```

##### 算法3：求顺序栈长度 √

- ```c
  int StackLength(SqStack S)
  {
      return S.top-S.base;//涉及指针减指针这一特殊情况
  }
  ```

##### 算法4：清空栈	√（存疑）

- 类C代码：

  - ```c
    Status ClearStack(SqStack &S)
    {
        if(S.base)
            S.top=S.base;//直接将栈顶指针指向栈底指针
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status ClearSqStack(SqStack* S)
    {
    	if(S->base)
    		S->top = S->base;
    	return OK;
    }
    ```

##### 算法5：销毁栈 √

- 类C代码：

  - ```c
    Status DestroyStack(SqStack &S)
    {
        if(S.base)
        {
            free(S.base);
            S.stacksize=0 ;
            S.base=S.top=NULL;
        }
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status DestroySqStack(SqStack* S)
    {
    	if (!S->base)
    		return ERROR;
    	free(S->base);
    	S->top = S->base = NULL;
    	S->stacksize = 0;
    	return OK;
    }
    ```

##### 算法6：顺序栈的入栈 √

- 类C代码：

  - ```c
    /*
    1.判断是否栈满，若满则返回上溢;判断存储空间是否存在
    2.元素e压入栈顶
    3.栈顶指针加一
    */
    Status Push(SqStack &S,SElemType e)
    {
        if(S.top-S.base == stacksize)
        	return ERROR;//或OVERFLOW
        *S.top=e;
        S.top++;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status Push(SqStack* S, SElemType* e)
    {
    	if (!S->base || S->top - S->base == S->stacksize)		//栈为NULL,或者上溢
    		return ERROR;
    	*(S->top) = *e;
        S->top++;
    	return OK;
    }
    ```
    
  - ```c
    Status Push(SqStack* S, SElemType e)
    {
    	if (!S->base || S->top - S->base == S->stacksize)		//栈为NULL,或者上溢
    		return ERROR;
    	*(S->top) = e;
        S->top++;
    	return OK;
    }
    ```

##### 算法7：顺序栈的出栈 √

- 类C代码：

  - ```c
    /*
    1.判断是否栈空，若空则下溢
    2.栈顶指针减一
    3.获取栈顶元素e
    */
    Status Pop(SqStack &S,SElemType &e)
    {
        if(S.top == S.base)
        	return ERROR;
        --S.top;
        e=*S.top;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status Pop(SqStack* S, SElemType* e)
    {
    	if (!S->base || S->top == S->base)						//栈为NULL,或者下溢
    		return ERROR;
        --S->top;
    	*e = *S->top;
    	return OK;
    }
    ```

##### 算法8：显示栈 √

- C语言实现：

  - ```c
    void ShowSqStack(const SqStack* S)
    {
    	if (!S->base || S->top == S->base)
    		printf("栈空!\n");
    	SElemType* p = S->top;
    	while (p-- != S->base)
    	{
    		printf("%d ", *p);
    	}
    	putchar('\n');
    }
    ```
    
  - ```c
    void ShowSqStack(SqStack S)
    {
    	if (!S.base || S.top == S.base)
    		printf("栈空!\n");
    	SElemType* p = S.top;
    	while (p != S.base)
    	{
    		p--;
            printf("%d ", *p);
    	}
    	putchar('\n');
    }
    ```

##### 顺序栈完整代码

- ```c++
  #define _CRT_SECURE_NO_WARNINGS
  #include<stdio.h>
  #include<stdlib.h>
  
  #define MAXSIZE 10  //定义栈中元素的最大个数
  #define OK 1	//成功标志
  #define ERROR 0	//失败标志
  #define TRUE 1
  #define FALSE 0
  #define OVERFLOW -1
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int SElemType;	
  
  typedef struct
  {
  	SElemType *base;//栈底指针
  	SElemType *top;//栈顶指针
  	int stacksize;//栈可用最大容量
  }SqStack;
  
  //函数声明
  Status InitSqStack(SqStack* S);	//顺序栈的初始化
  Status IsEmptySqStack(SqStack S);	//判断顺序栈是否为空
  Status IsFullSqStack(SqStack S);	//判断顺序栈是否已满
  int StackLength(SqStack S);	//求顺序栈长度
  Status ClearSqStack(SqStack* S);	//清空栈
  Status DestroySqStack(SqStack* S);	//销毁栈
  Status Push(SqStack* S, SElemType e);	//顺序栈的入栈
  Status Pop(SqStack* S, SElemType* e);	//顺序栈的出栈
  void ShowSqStack(SqStack S);	//栈显示函数
  void test(SqStack *s);	//测试函数
  
  int main()
  {
  	SqStack s;
  	int e = 0;
  	int a = 0;	//用于判断返回值真假
  	int length = 0;
  
  	InitSqStack(&s);	//顺序栈的初始化
  	test(&s);
  	
  
  	//依次入栈1~10，10个元素
  	for (int i = 1; i <= 10; i++)
  	{
  		Push(&s, i);
  		test(&s);
  	}
  
  	//依次出栈1~10，10个元素
  	for (int i = 1; i < 10; i++)
  	{
  		Pop(&s, &e);
  		printf("第 %d 个弹出的元素为 %d \n", i, e);
  		test(&s);
  	}
  
  	//依次入栈1~10，10个元素
  	for (int i = 1; i <= 10; i++)
  	{
  		Push(&s, i);
  	}
  	ClearSqStack(&s);
  	test(&s);
  
  	return 0;
  }
  
  //顺序栈的初始化
  Status InitSqStack(SqStack* S)
  {
  	S->base = (SElemType*)malloc(MAXSIZE * sizeof(SElemType));
  	if (!S->base)			//S->base为NULL，开辟空间失败
  		exit(OVERFLOW);
  	S->top = S->base;
  	S->stacksize = MAXSIZE;
  	return OK;
  }
  
  //判断顺序栈是否为空
  Status IsEmptySqStack(SqStack S)
  {
  	if (S.base == S.top)
  		return TRUE;
  	else
  		return FALSE;
  }
  
  //判断顺序栈是否已满
  Status IsFullSqStack(SqStack S)
  {
  	if (!S.base)
  		return ERROR;
  	if (S.top - S.base == S.stacksize)
  		return TRUE;
  	else
  		return FALSE;
  }
  
  //求顺序栈长度
  int StackLength(SqStack S)
  {
  	return (S.top - S.base);//涉及指针减指针这一特殊情况
  }
  
  //清空栈
  Status ClearSqStack(SqStack* S)
  {
  	if (S->base)
  		S->top = S->base;
  	return OK;
  }
  
  //销毁栈
  Status DestroySqStack(SqStack* S)
  {
  	if (!S->base)
  		return ERROR;
  	free(S->base);
  	S->top = S->base = NULL;
  	S->stacksize = 0;
  	return OK;
  }
  
  //顺序栈的入栈
  Status Push(SqStack* S, SElemType e)
  {
  	if (!S->base || S->top - S->base == S->stacksize)		//栈为NULL,或者上溢
  		return ERROR;
  	*(S->top) = e;
  	S->top++;
  	return OK;
  }
  
  //顺序栈的出栈
  Status Pop(SqStack* S, SElemType* e)
  {
  	if (!S->base || S->top == S->base)						//栈为NULL,或者下溢
  		return ERROR;
  	S->top--;
  	*e = *S->top;
  	return OK;
  }
  
  //栈显示函数
  void ShowSqStack(SqStack S)
  {
  	if (!S.base || S.top == S.base)
  		printf("栈空!\n");
  	SElemType* p = S.top;
  	while (p != S.base)
  	{
  		p--;
  		printf("%d ", *p);
  	}
  	putchar('\n');
  }
  
  //测试函数
  void test(SqStack *s)
  {
  	int a = 0;
  	int length = 0;
  	SqStack m = *s;
  
  	a = IsEmptySqStack(m);	//判断顺序栈是否为空
  	if (a == 1)
  	{
  		printf("栈空\n");
  	}
  	else
  	{
  		printf("栈非空\n");
  	}
  
  	a = IsFullSqStack(m);	//判断顺序栈是否已满
  	if (a == 1)
  	{
  		printf("栈满\n");
  	}
  	else
  	{
  		printf("栈非满\n");
  	}
  
  	length = StackLength(m);	//求顺序栈长度
  	printf("栈的长度为 %d\n",length);
  
  	ShowSqStack(m);	//栈显示函数
  	printf("\n");
  }
  ```

### 4.链栈的表示和实现

#### （1）.链栈的表示

- 链栈是操作受限的单链表，只能在链表头部进行操作

- ```c
  typedef struct StackNode
  {
      SElemType data;	//数据域
      struct StackNode *next;	//next域
  }StackNode,*LinkStack;
  
  LinkStack S;//
  ```

- 链表的头指针就是栈顶

- 不需要头结点

- 基本不存在栈满的情况

- 空栈相当于头指针指向空

- 插入和删除仅在栈顶处执行

#### （2）.链栈的基本操作实现

##### 算法1：链栈的初始化

- 类C代码：

  - ```c
    void InitStack(LinkStack &S)
    {
        //构建一个空栈，栈顶指针置空
        S=NULL;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    //带有头结点（？？？），应该不需要
    Status InitLinkStack(LinkStack* S)
    {
    	*S = (LinkStack)malloc(sizeof(StackNode));
    	if (!S)			//开辟空间失败
    		return ERROR;
    	(*S)->next = NULL;//(???)
    	return OK;
    }
    ```

  - ```c
    //不带头结点
    void InitStack(LinkStack* S)
    {
    	*S=NULL;//不需要头结点
    }
    ```

##### 算法2：判断链栈是否为空

- 类C代码：

  - ```c
    Status StackEmpty(LinkStack S)
    {
        if(S == NULL)
            return TRUE;
        return FALSE;
    }
    ```

- C语言实现：

  - ```c
    //带头结点,地址传递
    Status IsEmptyLinkStack(LinkStack* S)
    {
    	if ((*S)->next == NULL)	
    		return TRUE;
    	return FALSE;
    }
    ```

  - ```c
    //不带头结点，值传递
    Status stackEmpty(LinkStack S)
    {
    	if(S == NULL)
    		return TRUE;
    	return FALSE;
    }
    ```

##### 算法3：链栈的入栈

- 类C代码：

  - ```c
    Status StackPush(LinkStack &S,SElemType e)
    {
        p=(StackNode*)malloc(sizeof(StackNode));//生成新结点
        p->data=e;//将新结点数据域置为e
        p-next=S;//将新结点插入栈顶
        S=p;//修改栈顶指针
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status Push(LinkStack* S, SElemType e)
    {
    	StackNode* new = (StackNode*)malloc(sizeof(StackNode));
    	new->data = e;
    	new->next = *S;
    	(*S) = new;
    	return OK;
    }
    ```

##### 算法4：链栈的出栈

- 类C代码：

  - ```c
    Status StackPop(LinkStack &S,SElemType &e)
    {
        if(S == NULL)
            return ERROR;
        e=S->data;
        p=S;//新建一个结点存放要释放的栈顶结点
        S=S->next;//栈顶指针下移
        free(p);//释放要删除的结点
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status Pop(LinkStack* S, SElemType* e)
    {
    	if ((*S) == NULL)			//判断链栈下溢
    		return ERROR;
    	StackNode* p = *S;
    	*e = p->data;
    	*S = p->next;
    	free(p);					//释放栈顶空间
    }
    ```

##### 算法5：取栈顶元素

- 类C代码：

  - ```c
    SElemType GetTop(LinkStack S)
    {
        if(S != NULL)
            return S->data;
    }
    ```

- C语言实现：

  - ```c
    //有头结点，二级指针
    SElemType GetTop(LinkStack* S)
    {
    	if ((*S)->next)
    		return (*S)->data;
    }
    ```

  - ```c
    //无头结点，二级指针
    SElemType GetTop(LinkStack* S)
    {
    	if (*S)
    		return (*S)->data;
    }
    ```

  - ```c
    //无头结点，一级指针
    SElemType GetTop(LinkStack S)
    {
    	if (S)
    		return S->data;
    }
    ```

##### 算法6：显示栈

- C语言实现：

  - ```c
    //有头结点，二级指针
    void ShowLinkStack(const LinkStack* S)
    {
    	if (!(*S)->next)
    	{
    		printf("The LinkStack is Empty\n");
    		return;
    	}
    	else if (!(*S))
    	{
    		printf("The LinkStack dosen't  exsist\n");
    	}
    	StackNode* p;
    	p = *S;
    	while (p->next)
    	{
    		printf("%d ", p->data);
    		p = p->next;
    	}
    	putchar('\n');
    }
    ```
    
  - ```c
    //无头结点，一级指针
    void ShowLinkStack(LinkStack S)
    {
    	if (S == NULL)
    	{
    		printf("链栈为空\n");
    		return;
    	}
    	StackNode* p;
    	p = S;
    	while (p)
    	{
    		printf("%d ", p->data);
    		p = p->next;
    	}
    	putchar('\n');
    }
    ```

##### 链栈完整代码

- ```c
  #define _CRT_SECURE_NO_WARNINGS
  #include<stdio.h>
  #include<stdlib.h>
  
  #define MAXSIZE 10  //定义栈中元素的最大个数
  #define OK 1	//成功标志
  #define ERROR 0	//失败标志
  #define TRUE 1
  #define FALSE 0
  #define OVERFLOW -1
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int SElemType;
  
  typedef struct StackNode
  {
  	SElemType data;	//数据域
  	struct StackNode *next;	//next域
  }StackNode, *LinkStack;
  
  //函数声明
  void InitStack(LinkStack* S);	//链栈初始化（不带头结点）
  Status stackEmpty(LinkStack S);	//判断链栈是否为空
  Status Push(LinkStack* S, SElemType e);	//链栈的入栈
  Status Pop(LinkStack* S, SElemType* e);	//链栈的出栈
  SElemType GetTop(LinkStack S);	//取栈顶元素
  void ShowLinkStack(LinkStack S);	//显示链栈
  
  int main()
  {
  	int a = 0;
  	int e = 0;
  	LinkStack S;
  	InitStack(&S);
  	a = stackEmpty(S);
  	if (a == 1)
  	{
  		printf("链栈为空\n");
  	}
  	else
  	{
  		printf("链栈非空\n");
  	}
  	ShowLinkStack(S);
  	//依次入栈1~10
  	for (int i = 1; i <= 10; i++)
  	{
  		Push(&S, i);
  		printf("第 %d 个入栈的元素是 %d \n", i, i);
  		a = stackEmpty(S);
  		if (a == 1)
  		{
  			printf("栈空\n");
  		}
  		else
  		{
  			printf("栈非空\n");
  		}
  		printf("栈中元素为：");
  		ShowLinkStack(S);
  	}
  	//依次出栈
  	for (int i = 1; i <= 10; i++)
  	{
  		Pop(&S, &e);
  		printf("第 %d 个出栈的元素是 %d \n", i, e);
  		a = stackEmpty(S);
  		if (a == 1)
  		{
  			printf("栈空\n");
  		}
  		else
  		{
  			printf("栈非空\n");
  		}
  		ShowLinkStack(S);
  	}
  
  	return 0;
  }
  
  //链栈初始化（不带头结点）
  void InitStack(LinkStack* S)
  {
  	*S = NULL;//不需要头结点
  }
  
  //判断链栈是否为空
  Status stackEmpty(LinkStack S)
  {
  	if (S == NULL)
  		return TRUE;
  	return FALSE;
  }
  
  //链栈的入栈
  Status Push(LinkStack* S, SElemType e)
  {
  	StackNode* new = (StackNode*)malloc(sizeof(StackNode));
  	new->data = e;
  	new->next = *S;
  	(*S) = new;
  	return OK;
  }
  
  //链栈的出栈
  Status Pop(LinkStack* S, SElemType* e)
  {
  	StackNode* p = *S;
  	if ((*S) == NULL)			//判断链栈下溢
  		return ERROR;
  	*e = p->data;
  	*S = p->next;
  	free(p);					//释放栈顶空间
  }
  
  //取栈顶元素
  SElemType GetTop(LinkStack S)
  {
  	if (S)
  		return S->data;
  }
  
  //显示链栈
  void ShowLinkStack(LinkStack S)
  {
  	if (S == NULL)
  	{
  		printf("链栈为空\n");
  		return;
  	}
  	StackNode* p;
  	p = S;
  	while (p)
  	{
  		printf("%d ", p->data);
  		p = p->next;
  	}
  	putchar('\n');
  	putchar('\n');
  }
  ```

## （四）栈和递归

### 1.递归的定义

- 若一个对象部分的包含他自己，或用他自己给自己定义，则称这个对象是递归的
- 若一个过程之间或间接地调用自己，则称这个过程是递归的过程
  - ed：递归求n的阶乘

### 2.常用递归方法的情况

1. 递归定义的数学函数
   1. 阶乘函数
   2. 斐波那契数列
2. 具有递归特性的数据结构
   1. 二叉树
   2. 广义表
3. 可递归求解的问题
   1. 迷宫问题
   2. 汉诺塔问题

### 3.递归问题

- 用分治法求解
  - 分治法：对于一个较复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解
- 必备的三个条件：
  1. 能够将一个问题转变成一个新问题，且新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是有变化规律的
  2. 可以通过上述转化使问题简化
  3. 必须有一个明确的递归出口，或称为递归的边界

### 4.函数调用过程

- 调用前，系统完成：
  1. 将实参、返回地址等传递给被调用函数
  2. 为被调函数的局部变量分配存储区域
  3. 将控制转移到被调函数的入口
- 调用后，系统完成：
  1. 保存被调函数的计算结果
  2. 释放被调函数的数据区
  3. 依照被调函数保存的返回地址将控制转移到被调函数

## （五）队列的表示和实现

### 1. 队列的抽象数据类型：

- ```c
  ```

### 2. 顺序队列的基本操作实现

#### （1）.队列的顺序表示

- 用一维数组base[MAXSIZE]

- 循环队列的结构

  - ```c
    #define MAXSIZE 100//最大队列长度
    typedef struct
    {
    	QElemType *base;//初始化动态分配存储空间
        int front;//头指针（实际是队头元素下标）
        int rear;//尾指针（实际是队尾元素下标）
    }SqQueue;
    ```

- 初始:

  - ```c
    cfront=rear=0
    ```

- 入队

  - ```c
    base[rear]=x;
    rear++;
    ```

- 出队

  - ```c
    x=base[front];
    front++;
    //空队标志
    front==rear;
    ```

- 真溢出

  - ```c
    front=0;
    rear=MAXSIZE;
    ```

- 假溢出

  - ```c
    front!=0;
    rear=MAXSIZE;
    ```

#### （2）.解决假上溢的方法

1. 将队中元素依次向队头方向移动

   - 缺点：浪费时间，每移动一次，队中元素都要移动

2. 将队空间想象成一个循环的表，即分配给队列的m个存储单元可以循环使用，当rear为MAXSIZE时，若向量的开始端空着，则又可以开始从头使用空着的空间，当front为MAXSIZE时，也是一样

   - 引入循环队列：base[0]接在base[MAXSIZE-1]之后，若rear+1==M，则令rear=0;

     - 实现方法：利用模运算

     - 插入元素：

       - ```c
         Q.base[Q.rear]=x;
         Q.rear=(Q.rear+1)%MAXSIZE;
         ```

     - 删除元素：

       - ```c
         x=Q.base[Q.front];
         Q.front=(Q.front+1)%MAXSIZE;
         ```

     - 循环队列队空和队满标志冲突
     
       - front==rear
       - 解决方案：
         1. 另外设一个标志以区别队空队满
         2. 另设一个变量，记录元素个数
         3. 少用一个元素空间（采用）
            - 队空：front==rear
            - 队满：（rear+1）%MAXSIZE==front
     

#### （3）.循环队列的操作

##### 算法1：队列的初始化

- 类C代码：

  - ```c
    Status InitQueue(SqQueue &Q)
    {
        Q.base=(QElemType*)malloc(MAXSIZE*sizeof(QElemType));//分配数组空间
        if(!Q.base)
            exit(OVERFLOW);//存储分配失败
        Q.front=Q.rear=0;//头指针尾指针都置为零，队列为空
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status InitSqQueue(SqQueue* Q)
    {
    	Q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
    	if (!Q->base)
    		return ERROR;
    	Q->front = Q->rear = 0;
    	return OK;
    }
    ```

##### 算法2：求队列长度

- 类C代码：

  - ```c
    int QueueLength(SqQueue Q)
    {
        return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;//解决了循环队列中尾指针到头指针前面的情况
    }
    ```

- C语言实现：

  - ```c
    //传址调用
    int GetLength(SqQueue* Q)
    {
    	return ((Q->rear - Q->front + MAXSIZE) % MAXSIZE);
    }
    ```

  - ```c
    //传值调用
    int QueueLength(SqQueue Q)
    {
        return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
    }
    ```

##### 算法3：循环队列入队

- 类C代码：

  - ```c
    Status EnQueue(SqQueue &Q,QElemType e)
    {
        if((Q.rear + 1) % MAXSIZE == front)
            return ERROR;//判断队满
        Q.base[Q.rear] = e;//新元素加入队尾
        Q.rear = (Q.rear + 1) % MAXSIZE;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status EnQueue(SqQueue* Q, QElemType e)
    {
    	if ((Q->rear + 1) % MAXQSIZE == Q->front)		//出现上溢
    		return ERROR;
    	Q->base[Q->rear] = e;
    	Q->rear = (Q->rear + 1) % MAXQSIZE;
    	return OK;
    }
    ```

##### 算法4：循环队列出队

- 类C代码：

  - ```c
    Status OutQueue(SqQueue &Q,QElemType &e)
    {
        if(Q.rear == Q.front)
            return ERROR;//判断队空
        e=Q.base[front];//保存队头元素
        Q.front=(Q.front+1)%MAXSIZE;//队头指针加一（但不会超过MAXSIZE-1）
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status DeQueue(SqQueue* Q, QElemType* e)
    {
    	if (Q->front == Q->rear)				//出现下溢
    		return ERROR;
    	*e = Q->base[Q->front];
    	Q->front = (Q->front + 1) % MAXQSIZE;
    	return OK;
    }
    ```

##### 算法5：取队头元素

- 类C代码：

  - ```c
    QElemType GetHead(SqQueue Q)
    {
        if(Q.front==Q.rear)
            return ERROR;
        return Q.base[Q.front];//返回队头元素的值，队头指针不动
    }
    ```

- C语言实现：

  - ```c
    //传址调用
    QElemType GetHead(SqQueue* Q)
    {
    	if (Q->rear == Q->front)
             return ERROR;
    	return Q->base[Q->front];
    }
    ```

  - ```c
    //传值调用
    QElemType GetHead(SqQueue Q)
    {
        if(Q.front==Q.rear)
            return ERROR;
        return Q.base[Q.front];
    }
    ```

##### 算法6：销毁队列

- C语言实现：

  - ```c
    Status DestoryQueue(SqQueue* Q)
    {
    	if (!(Q->base))
    		return ERROR;
    	free(Q->base);
    	Q->front = Q->rear = 0;
    	return OK;
    }
    ```

##### 算法7：显示队列

- C语言实现：

  - ```c
    void ShowSqQueue(SqQueue Q)
    {
    	if (Q.front == Q.rear)
    	{
    		printf("The SqQueue is Empty\n");
    		return;
    	}
    	while (Q.rear != Q.front)
    	{
    		printf("%d ", Q.base[Q.front]);
    		Q.front = (Q.front + 1) % MAXQSIZE;//可以直接使用队头指针移动，因为这是值传递不会改变原队列中的队头指针
    	}
    	putchar('\n');
    }
    ```

##### 顺序队列完整代码

- 注意：测试不完全，假上溢未测试

- ```c
  #define _CRT_SECURE_NO_WARNINGS
  #include<stdio.h>
  #include<stdlib.h>
  
  #define MAXQSIZE 50  //定义队列中元素的最大个数
  #define OK 1	//成功标志
  #define ERROR 0	//失败标志
  #define TRUE 1
  #define FALSE 0
  #define OVERFLOW -1
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int QElemType;
  
  typedef struct
  {
  	QElemType *base;//初始化动态分配存储空间
  	int front;//头指针（实际是队头元素下标）
  	int rear;//尾指针（实际是队尾元素下标）
  }SqQueue;
  
  //函数声明
  Status InitSqQueue(SqQueue* Q);	//队列初始化
  int QueueLength(SqQueue Q);	//求队列长度
  Status EnQueue(SqQueue* Q, QElemType e);	//循环队列入队
  Status DeQueue(SqQueue* Q, QElemType* e);	//循环队列出队
  QElemType GetHead(SqQueue Q);	//取队头元素（不出队）
  Status DestoryQueue(SqQueue* Q);	//销毁队列
  void ShowSqQueue(SqQueue Q);	//显示队列
  
  int main()
  {
  	int e = 0;
  	SqQueue Q;
  	InitSqQueue(&Q);
  	printf("此时队头元素是 %d \n", GetHead(Q));
  	printf("此时列长度为 %d \n", QueueLength(Q));
  	printf("此时队列中的元素为：");
  	ShowSqQueue(Q);
  	printf("\n");
  
  	//依次入队1~5
  	for (int i = 1; i <= 5; i++)
  	{
  		printf("第 %d 个入队的元素是 %d \n", i, i);
  		EnQueue(&Q, i);
  		printf("此时队头元素是 %d \n", GetHead(Q));
  		printf("此时列长度为 %d \n", QueueLength(Q));
  		printf("此时队列中的元素为：");
  		ShowSqQueue(Q);
  		printf("\n");
  	}
  	//依次出队1~5个元素
  	for (int i = 1; i <= 5; i++)
  	{
  		DeQueue(&Q, &e);
  		printf("第 %d 个出队的元素是 %d \n", i, e);
  		printf("此时队头元素是 %d \n", GetHead(Q));
  		printf("此时列长度为 %d \n", QueueLength(Q));
  		printf("此时队列中的元素为：");
  		ShowSqQueue(Q);
  		printf("\n");
  	}
  
  	return 0;
  }
  
  //队列初始化
  Status InitSqQueue(SqQueue* Q)
  {
  	Q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
  	if (!Q->base)
  		return ERROR;
  	Q->front = 0;
  	Q->rear = 0;
  	return OK;
  }
  
  //求队列长度
  int QueueLength(SqQueue Q)
  {
  	return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
  }
  
  //循环队列入队
  Status EnQueue(SqQueue* Q, QElemType e)
  {
  	if ((Q->rear + 1) % MAXQSIZE == Q->front)		//判断是否出现上溢
  		return ERROR;
  	Q->base[Q->rear] = e;
  	Q->rear = (Q->rear + 1) % MAXQSIZE;
  	return OK;
  }
  
  //循环队列出队
  Status DeQueue(SqQueue* Q, QElemType* e)
  {
  	if (Q->front == Q->rear)	//判断是否出现下溢（队空）
  		return ERROR;
  	*e = Q->base[Q->front];
  	Q->front = (Q->front + 1) % MAXQSIZE;
  	return OK;
  }
  
  //取队头元素（不出队）
  QElemType GetHead(SqQueue Q)
  {
  	if (Q.front == Q.rear)
  		return ERROR;
  	return Q.base[Q.front];
  }
  
  //销毁队列
  Status DestoryQueue(SqQueue* Q)
  {
  	if (!(Q->base))
  		return ERROR;
  	free(Q->base);
  	Q->base = NULL;
  	Q->front = Q->rear = 0;
  	return OK;
  }
  
  //显示队列
  void ShowSqQueue(SqQueue Q)
  {
  	if (Q.front == Q.rear)
  	{
  		printf("队列为空\n");
  		return;
  	}
  	while (Q.rear != Q.front)
  	{
  		printf("%d ", Q.base[Q.front]);
  		Q.front = (Q.front + 1) % MAXQSIZE;	//可以直接使用队头指针移动，因为这是值传递，不会改变原队列中的队头指针
  	}
  	putchar('\n');
  }
  ```

### 3.链式队列的表示和实现

- 若用户无法估计所用队列的长度，则采用链队列

#### （1）.链队列的类型定义

- ```c
  typedef struct QNode
  {
      QElemType data;
      struct QNode *next;
  }QNode,*QueuePtr;//链队列结点，链队列指针
  typedef struct
  {
      QueuePtr front;//队头指针
      QueuePtr rear;//队尾指针
  }LinkQueue;//链队列
  ```

#### （2）.链队列的基本操作

##### 算法1：链队列初始化

- 类C代码：

  - ```c
    Status InitQueue(LinkQueue &Q)
    {
        Q.front=Q.rear=(QNode*)malloc(sizeof(QNode));
        if(!Q.front)
            exit(OVERFLOW);
        Q.front->next=NULL;//队头指针置空
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status InitLinkQueue(LinkQueue* Q)
    {
    	Q->front = (QNode*)malloc(sizeof(QNode));
        Q->rear = Q->front;
    	if (!Q->rear)
    		return ERROR;
    	Q->rear->next = NULL;
    	return OK;
    }
    ```

##### 算法2：销链队列

- 类C代码：

  - ```c
    //从队头结点开始依次释放所有结点
    Status DestroyQueue(LinkQueue &Q)
    {
        while(Q.front)
        {
            p=Q.front->next;//存放下一个结点，否则直接删除Q.front会找不到下一结点
            free(Q.front);	//第一次释放的是队头结点，不是首元结点
            Q.front=p;//移动队头结点
        }
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status DestoryLinkQueue(LinkQueue* Q)
    {
    	QNode* p;
    	while (Q->front)
    	{
    		p = Q->front->next;
    		free(Q->front);
    		Q->front = p;
    	}
    	return OK;
    }
    ```

##### 算法3：链队列的入队

- 类C代码：

  - ```c
    Status EnQueue(LinkQueue &Q,QElemType e)
    {
        p=(QNode*)malloc(sizeof(QNode));
        if(!p)
            exit(OVERFLOW);
        if((Q.rear+1)%MAXSIZE == Q.front)
            return ERROR;
        p->data=e;
        p->next=NULL;
        Q.rear->next=p;	
        Q.rear=p;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status EnQueue(LinkQueue* Q, QElemType e)
    {
    	QNode* p = (QNode*)malloc(sizeof(QNode));
    	p->data = e;
    	p->next = NULL;
    	Q->rear->next = p;
    	Q->rear = p;		//更新队列尾指针
    	return OK;
    }
    ```

##### 算法4：链队列的出队

- 类C代码：

  - ```c
    Status DeQueue(LinkQueue &Q,QElemType &e)
    {
        if(Q.front == Q.rear)
            return ERROR;//判断队空
        p=Q.front->next;
        e=p->data;
        Q.front->next=p->next;	//出队最后一个元素时，Q.front->next此时为NULL
        if(Q.rear == p)//如果链队列中元素个数为零了，还需要修改尾指针
            Q.rear=Q.front;	//此时头指针和尾指针都指向头结点，不为空
        free(p);
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status DeLinkQueue(LinkQueue* Q, QElemType* e)
    {
    	if (Q->front == Q->rear)
    		return ERROR;
    	QNode* p = Q->front->next;
    	*e = p->data;
    	Q->front->next = p->next;
    	if (Q->rear == p)
    		 Q->rear = Q->front;	//最后一个元素出队时，这里为什么不执行
    	free(p);
    	return OK;
    }
    ```

##### 算法5：求链队列的队头元素

- 类C代码：

  - ```c
    Status GetHead(LinkQueue Q,QElemType &e)
    {
        if(Q.front == Q.rear)
            return ERROR;//判断队空
        e=Q.front->next->data;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    QElemType GetHead(LinkQueue* Q)
    {
    	if(Q->front != Q->rear)
    		return Q->front->next->data;
    }
    ```

  - ```c
    Status GetHead(LinkQueue Q,QElemType *e)
    {
        if(Q.front == Q.rear)
            return ERROR;//判断队空
        *e = Q.front->next->data;
        return OK;
    }
    ```

##### 算法6：显示链队列

- ```c
  void ShowLinkQueue(LinkQueue Q)
  {
  	if (Q.front == Q.rear)
  	{
  		printf("链队列为空\n");
  		return;
  	}
  	Q.front = Q.front->next;	//跳过头结点，移动到首元结点
  	while (Q.front)
  	{
  		printf("%d ", Q.front->data);
  		Q.front = Q.front->next;
  	}
  	putchar('\n');
  	return OK;
  }
  ```

##### 链队列完整代码

- 传址调用时，在调用结束后，实参才会改变

- ```c
  #define _CRT_SECURE_NO_WARNINGS
  #include<stdio.h>
  #include<stdlib.h>
  
  #define MAXQSIZE 50  //定义队列中元素的最大个数
  #define OK 1	//成功标志
  #define ERROR 0	//失败标志
  #define TRUE 1
  #define FALSE 0
  #define OVERFLOW -1
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int QElemType;
  
  typedef struct QNode
  {
  	QElemType data;
  	struct QNode *next;
  }QNode, *QueuePtr;//链队列结点，链队列指针
  typedef struct
  
  {
  	QueuePtr front;//队头指针
  	QueuePtr rear;//队尾指针
  }LinkQueue;//链队列
  
  //函数声明
  Status InitLinkQueue(LinkQueue* Q);	//链队列初始化
  Status DestoryLinkQueue(LinkQueue* Q);	//链队列销毁
  Status EnQueue(LinkQueue* Q, QElemType e);	//链队列入队
  Status DeLinkQueue(LinkQueue* Q, QElemType* e);	//链队列出队
  Status GetHead(LinkQueue Q, QElemType *e);	//求队头元素
  void ShowLinkQueue(LinkQueue Q);	//显示链队列
  
  int main()
  {
  	int e = 0;
  	int a = 0;
  	LinkQueue Q;
  	InitLinkQueue(&Q);
  	a = GetHead(Q, &e);
  	if (a == 0)
  	{
  		printf("此时链表为空\n");
  	}
  	else
  	{
  		printf("此时队头元素为：%d \n", e);
  	}	
  	printf("此时链队列中元素为：");
  	ShowLinkQueue(Q);
  	printf("\n");
  
  	//依次入队1~5
  	for (int i = 1; i <= 5; i++)
  	{
  		printf("第 %d 个入队的元素是 %d \n", i, i);
  		EnQueue(&Q, i);
  		a = GetHead(Q, &e);
  		if (a == 0)
  		{
  			printf("此时链表为空\n");
  		}
  		else
  		{
  			printf("此时队头元素为：%d \n", e);
  		}
  		printf("此时链队列中元素为：");
  		ShowLinkQueue(Q);
  		printf("\n");
  	}
  	//依次出队1~5个元素
  	for (int i = 1; i <= 5; i++)
  	{
  		DeLinkQueue(&Q, &e);
  		printf("第 %d 个出队的元素是 %d \n", i, e);
  		a = GetHead(Q, &e);
  		if (a == 0)
  		{
  			printf("此时链表为空\n");
  		}
  		else
  		{
  			printf("此时队头元素为：%d \n", e);
  		}
  		printf("此时链队列中元素为：");
  		ShowLinkQueue(Q);
  		printf("\n");
  	}
  
  
  	return 0;
  }
  
  //链队列初始化
  Status InitLinkQueue(LinkQueue* Q)
  {
  	Q->front = (QNode*)malloc(sizeof(QNode));
  	Q->rear = Q->front;
  	if (!Q->rear)
  		return ERROR;
  	Q->rear->next = NULL;
  	return OK;
  }
  
  //链队列销毁
  Status DestoryLinkQueue(LinkQueue* Q)
  {
  	QNode* p;
  	while (Q->front)
  	{
  		p = Q->front->next;
  		free(Q->front);
  		Q->front = p;
  	}
  	return OK;
  }
  
  //链队列入队
  Status EnQueue(LinkQueue* Q, QElemType e)
  {
  	QNode* p = (QNode*)malloc(sizeof(QNode));
  	p->data = e;
  	p->next = Q->rear->next;	//尾指针的next不就是NULL吗，这一步可以直接改成 p->next = NULL; 吗
  	Q->rear->next = p;
  	Q->rear = p;		//更新队列尾指针
  	return OK;
  }
  
  //链队列出队
  Status DeLinkQueue(LinkQueue* Q, QElemType* e)
  {
  	QNode* p = Q->front->next;	//指向首元结点，用于暂时保存首元结点，之后释放
  	if (Q->front == Q->rear)	//判断队空
  		return ERROR;	
  	*e = p->data;
  	Q->front->next = p->next;
  	if (Q->rear == p)
  	{
  		Q->rear = Q->front;	
  	}		
  	free(p);
  	return OK;
  }
  
  //求队头元素
  Status GetHead(LinkQueue Q, QElemType *e)
  {
  	if (Q.front == Q.rear)	//判断队空
  		return ERROR;
  	*e = Q.front->next->data;
  	return OK;
  }
  
  //显示链队列
  void ShowLinkQueue(LinkQueue Q)
  {
  	if (Q.front == Q.rear)
  	{
  		printf("链队列为空\n");
  		return;
  	}
  	Q.front = Q.front->next;	//跳过头结点，移动到首元结点
  	while (Q.front)
  	{
  		printf("%d ", Q.front->data);
  		Q.front = Q.front->next;
  	}
  	putchar('\n');
  	return OK;
  }
  ```

# 四.串、数组和广义表

## （一）串

### 1.串的定义：

- 零个或多个任意字符组成的有限序列
- eg：S="abcdefg" (n>=0)
  - S为串名
  - abcdefg为串值
  - n为串长；若n为零，则称为空串
- 几个术语：
  - 空格串：是只包含空格的串，可以有一个或多个空格
    - 注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格
  - 子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串
    - 真字串：不包含自身的所有子串
  - 字符位置：字符在序列中的序号为该字符在串中的位置
  - 子串位置：子串的第一个字符在主串中的序号
  - 串相等：当且仅当两个串的长度相等且对应位置上的字符都相同时，这两个串才相等
    - 所有的空串都相等

### 2. 案例引入

- 案例一：病毒感染检测
  - 案例实现：
    - 对于每一个待检测的任务，假设病毒DNA序列的长度是m，因为病毒DNA序列是环状的，为了线性取到每个可行的长度为m的字符串，可将存储病毒DNA序列的字符串长度扩大到2m，将病毒DNA序列连续存储两次
    - 然后循环m次，依次取得每个长度为m的环状字符串，将此字符作为模式串，将人的DNA序列作为主串，调用BF算法进行模式匹配
    - 只要匹配成功，即可终止循环，表明该人感染了病毒；否则，循环m次结束后，可通过BF算法的返回值判断该人是否感染了对应的病毒



### 3. 串的抽象数据类型定义

- ```c
  ADT String
  {
      数据对象：D={ai|ai∈CharacterSet,i=1,2,3,...,n,n>=0}
      数据关系：
      基本操作：
          1.StrAssign(&T,chars)//串赋值
          2.StrCompare(S,T)//串比较
          3.StrLength(S)//求串长
          4.Concat(&T,S1,S2)//串连结
          5.SubString(&Sub,pos,len)//求子串
          6.StrCopy(&T,S)//串拷贝
          7.StrEmpty(S)//串判空
          8.ClearString(&S)//清空串
          9.lndex(S,T,pos)//子串的位置
          10.Replace(&S,T,V)//串替换
          11.StrInsert(&S,pos,T)//子串插入
          12.StrDelete(&S,pos,len)//子串删除
          13.DestroyString(&S)//串销毁
  }ADT String
  ```

### 4. 顺序串

#### 顺序串的存储结构

- 用的更多，因为字符串操作很少需要插入删除

- ```c
  #define MAXSIZE 255
  typedef struct
  {
      char ch[MAXSIZE+1];//存储串的一维数组，下标为0的位置闲置（在某些算法中会带来简便），从下标为1的位置开始存放
      int length;//串的当前长度
  }SString;//第一个S表示“顺序”
  ```

### 5.链串

#### 链串的存储结构---块链结构

- ```c
  #define CHUNKSIZE 80 //块的大小由用户定义
  typedef struct Chunk
  {
      char ch[CHUNKSIZE];
      struct Chunk *next;
  }Chunk;
  typedef struct
  {
      Chunk *head,*tail; //串的头指针和尾指针
      int curlen; //串的当前长度
  }LString; //字符串的块链结构
  ```

  - 优点：操作方便
  - 缺点：存储密度较低
  - 可以将多个字符存放在一个结点内，以克服存储密度较低的缺点

### 6.串的模式匹配算法（BF和KMP)

- b站视频：天勤KMP，凡三岁KMP

- 算法目的：

  - 确定主串中所含子串第一个出现的位置（定位）

- 算法应用：

  - 搜索引擎、拼写检查、语言翻译、数据压缩

- 算法种类：

  - BF算法（Brute-Force，又称古典的、经典的、朴素的、穷举的）

    - 又称简单匹配算法，采用穷举的思路0

    - 算法思路：从S（主串：正文串）的每一个字符开始依次与T（子串：模式）的字符进行匹配

      - `Index(S,T,pos)`
        - 将主串的第pos个字符与模式串的第一个字符比较
          - 若相等，继续逐个比较后续字符
          - 若不相等，从主串下一个字符起，重新与模式串的第一个字符比较
        - 直到主串的一个连续子串字符序列与模式串相等，返回值为S与T中匹配的子序列第一个字符的序号，即匹配成功
        - 否则，匹配失败，返回0

    - ```c
      int Index_BF(SString S,SString T)
      {
          int i=1,j=1;
          while(i<=S.length && j<=T.length)
          {
              if(S.ch[i] == T.ch[j]) //比较成功时，主串和子串依次匹配下一个字符
                 {
                     ++i;
                     ++j;
                 }
              else //主串、子串指针回溯，重新开始下一次匹配      
              {
                  i=i-j+2;//i-(j-1)+1	，回退 j-1 个，回到主串中这次比较时开始的位置，+1表示从下一个位置开始下一轮的比较
                  j=1;
              }
          }
          if(j >= T.length)
              return i-T.length;//返回匹配的第一个字符下标
          return 0;//未匹配成功
      }	
      ```

    - BF算法的时间复杂度：

      - 若主串长度为n，子串长度为n，最坏情况下：主串前面n-m个位置都匹配到了子串的最后一位，即n-m个位置各比较了m次，最后m位也各比较了1次
        - 总次数为：(n-m)*m+m
        - 若m<<n，则算法的时间复杂度为Q(n*m)

  - KMP算法（特点：速度快）

    - 较BF算法有较大改进，主串S的指针 i 不再回溯，可提速至O(m+n)

      - 注意：**KMP算法中主串不再回退

    - 算法思路：
    
      - 不匹配时，寻找模式串中的最长公共前后缀，将前缀的位置后移到后缀的位置，再重新与主串匹配
        - 前缀：包含首位字符、但不包含末位字符的子串
        - 后缀：包含末位字符、但不包含首位字符的子串
        - 寻找公共前后缀时：前缀是从匹配的0第一个字符开始，后缀是从匹配成功的最后一个字符开始往前扩大范围寻找，但判断前后缀是否相同仍然是从左往右读（可能描述不太准确）
    
      - 移动模式串后几号位置与主串当前位比较？ **最大公共前后缀长度+1**
    
    - 需要定义函数求解 next数组 ：当主串与模式串某一位置不匹配时，模式串要回退的位置
    
      - `next[j]`	=
        - 0    当 j = 1 时
        - 1    当 j = 2 时
        - 最大公共前后缀长度+1（第 j 位字符前面 j-1 位字符组成的子串的前后置重合字符数 +1）    其他情况
      - 规律：
        - `next[j]`数组中的值每次最多递增1
        - 
    
    - 类C代码：
    
      - ```c
        //KMP算法
        int Index_KMP(SString S,SString T)	
        {
            int i=1,j=1;
            while(i<=S.length && j<=T.length)
            {
                if(S.ch[i] == T.ch[j]) //比较成功时，主串和子串依次匹配下一个字符
                   {
                       ++i;
                       ++j;
                   }
                else //主串、子串指针回溯，重新开始下一次匹配      
                {
                    j=next[j];
                }
            }
            if(j >= T.length)
                return i-T.length;//返回匹配的第一个字符下标
            return 0;//未匹配成功
        }	
        //求next数组
        void get_next(SString T,int &next[])
        {
            i=0;
            next[1]=0;
            j=0;
            while(i<T.length)
            {
                if(j==0 || T.ch[i]==T.ch[j])
                {
                    ++i;
                    ++j;
                    next[i]=j;
                }
                else
                    j=next[j];
            }
        }
        ```
  
  
  
  - BF算法和KMP算法简单演示完整代码：
  
    - ```c
      //BF算法和KMP算法的简单理解
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      #include<string.h>
      
      int Index_BF(char* a, char* b, int len1, int len2);	//BF算法
      int Index_KMP(char* a, char* b, int len1, int len2, int* next);	//KMP算法
      void get_next(char*b, int len, int* next);	//求next数组
      
      int main()
      {
      	char a[] = "aaaabc";
      	char b[] = "abc";
      	int len_a = strlen(a);
      	int len_b = strlen(b);
      	int next[4] = { 0 };
      	printf("BF求解出子串在主串中是位置是：%d\n", Index_BF(a, b, len_a, len_b));	
      	get_next(b, len_b, next);
      	printf("KP求解出子串在主串中是位置是：%d\n", Index_KMP(a, b, len_a, len_b, next));
      
      	return 0;
      }
      
      int Index_BF(char* a, char* b, int len1, int len2)
      {
      	int i = 1, j = 1;
      	while (i <= len1 && j <= len2)
      	{
      		if (a[i] == b[j]) //比较成功时，主串和子串依次匹配下一个字符
      		{
      			++i;
      			++j;
      		}
      		else //主串、子串指针回溯，重新开始下一次匹配      
      		{
      			i = i - j + 2;//i-(j-1)+1	，回退 j-1 个，回到主串中这次比较时开始的位置，+1表示从下一个位置开始下一轮的比较
      			j = 1;
      		}
      	}
      	if (j >= len2)
      		return i - len2;//返回匹配的第一个字符下标
      	return 0;//未匹配成功
      }
      
      int Index_KMP(char* a, char* b, int len1, int len2, int* next)
      {
      	int i = 1, j = 1;
      	while (i <= len1 && j <= len2)
      	{
      		if (j == 0 || a[i] == b[j]) //比较成功时，主串和子串依次匹配下一个字符
      		{
      			++i;
      			++j;
      		}
      		else //主串、子串指针回溯，重新开始下一次匹配      
      		{
      			j = next[j];
      		}
      	}
      	if (j > len2)
      		return i - len2;//返回匹配的第一个字符下标
      	return 0;//未匹配成功
      }
      void get_next(char* b, int len, int* next)
      {
      	int i = 1, j = 0;
      	next[1] = 0;	
      	while (i<len)
      	{
      		if (j == 0 || b[i] == b[j])
      		{
      			++i;
      			++j;
      			next[i] = j;
      		}
      		else
      		{
      			j = next[j];
      		}		
      	}
      }
      ```
  
  

## （二）数组

- 结论：线性表结构是数组元素的一个特例，而数组结构又是线性表结构的拓展

- 数组特点：结构固定，定义后维数和维界不再改变

- 数组基本操作：

  - 除了结构的初始化和销毁之外，只有去元素和修改元素值的操作

### 1. n维数组的抽象数据类型

- ```c
  ADT Array
  {
      数据对象：
      数据关系：
      基本操作：
          1.InitArray(&A,n,bound1,...,boundn) //构建数组A
          2.DestroyArray(&A) //销毁数组A
          3.Value(A,&e,index1,...,indexn) //去数组元素值
          4.Assign(A,&e,index1,...,indexn) //给数组元素赋值
  }ADT Array
  ```

### 2.数组的顺序存储

- 一般都采用顺序存储结构来表示数组
- 数组可以是多维的，但存储数据元素的内存单元地址的一维的，因此在存储数据结构之前，需要解决多维关系映射到一维关系的问题
- 二维数组两种顺序存储方式：
  - 以行序为主序（低下标优先）：BASIC、COBOL、PASCAL、Java、C
    - `数组元素a[i][j]的存储位置是:LOC(i,j)=LOC(0,0)+(n*i+j)*L`
  - 以行序为主序（高下标优先）：FORTRAN

### 3.特殊矩阵的压缩存储

- 不适宜常规存储的矩阵：值相同的元素且呈某种规律分布；零元素多
- 矩阵的压缩存储：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间
- 什么样的矩阵能压缩存储：
  - 对称矩阵
    - 特点：`a(ij)=a(ji)`    (沿对角线对称)
    - 存储方法：只存储下三角（或上三角）（包括主对角线）的元素。共占用n(n+1)/2个元素空间
    - 存储结构：以行序为主序将元素存在一个一维数组sa[n(n+1)/2]中
  - 对角矩阵
    - 特点：在 n×n 的方阵中，所有元素都集中在以主对角线为中心的带状区域中，区域外的值全为0
      - 常见的有：三对角矩阵、五对角矩阵。七对角矩阵
      - 存储方法：以对角线的顺序存储
  - 三角矩阵
    - 特点：对角线以上（或以下）的数据元素（不包括对角线）全部为常数C
    - 存储方法：重复元素共享一个存储空间，共占用n(n+1)/2+1个元素空间
    - 存储结构：以行序为主序将元素存在一个一维数组sa[n(n+1)/2+1]中
    - 下三角矩阵的元素位序k=
      - `i*(i-1)/2+j`       i>=j（对角线及下半区）
      - `n(n+1)/2+1`    i<j（上半区）
    - 上三角矩阵的元素位序k=
      - `(i-1)*(2n-i)/2+j-i+1 `   i<=j  (对角线及上半区）    ***未推导
      - `n(n+1)/2+1`
      - ​    i<j（下半区）
  - 稀疏矩阵：矩阵中非零元素少于百分之五
    - 方法一：三元组顺序表（又称有序的双下标法）
      - 压缩存储原则：存各非零元的值，行列位置和矩阵的行列数
      - 注意：为更可靠描述，通常再加一个总体信息，即总行数、总列数、总元素数
      - 优点：非零元在表中按行序有序储存，因此便于进行依行顺序处理的矩阵运算
      - 缺点：不能随机存取，若按行号存取某一行中的非零元，则需从头开始查找
    - 方法二：十字链表
      - 优点：能够灵活地插入因运算产生的的非零元素，删除运算产生的新零元素
      - 在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了（行，列，数值），还要有两个域：
        - right：用于链接同一行的下一个非零元素
        - down：用于链接同一列的下一个非零元素

## （三）广义表

### 1.广义表的定义

- 广义表（又称列表Lists），是n>=0个元素a0,a1,a2,...,an-1的有限序列，其中每个元素是一个原子或一个广义表
- 广义表通常记为  LS=(a1,a2,a3,...,an)
  - LS为表名，n为长度，每一个ai为表的元素
  - 表头：若LS非空，则第一个元素a1为表头
    - 记作：head(LS)=a1    (注意：表头可以是原子，也可以是子表)
  - 表尾：除表头的其他元素组成的表
    - 记作：tail(LS)=(a2,a3,...,an)   (注意：表尾不是最后一个元素，而是一个子表)

### 2.广义表的性质

- 广义表中的数据元素有相对次序，一个直接前驱和一个直接后继
- 广义表的长度定义为最外层所包含元素的个数
- 广义表的深度定义为该广义表展开后所包含的括号重数
  - 注：原子的深度为0，空表的深度为1
- 广义表可以和其他广义表共享
- 广义表可以是一个递归的表
- 广义表是一个多层次的结构，广义表的元素可以是单元素、也可以是子表，子表的元素还可以是子表

### 3.广义表和线性表的区别

- 广义表可以看成是线性表的推广，线性表是广义表的特例

### 4.广义表的运算

- 求表头运算GetHead(L)：非空广义表的第一个元素可以是一个原子，也可以是一个子表
- 求表尾运算GetTail(L)：非空广义表除去表头元素以外其他元素所构成的表，表尾一定是一个表

# 五.树和二叉树

## （一）树和二叉树的定义

### 1.树的定义

- 树是(Tree)n(n>=0)个结点的有限集（树的定义是一个递归的定义）
  - 若n=0，称为空树
  - n>0，则它满足两个条件：
    1. 有且仅有一个特定的称为根(Root)的结点
    2. 其余结点可分为m个互不相交的有限集T1,T2,T3...,Tm,其中每个集合本身又是一棵树，并称为根的子树(SubTree)

### 2.树的基本术语

- 根结点：非空树中无直接前驱的结点
- 结点的度：结点拥有的子树数
- 树的度：树内各结点的度的最大值
- 叶子结点（终端结点）：度为零的结点
- 分支结点/非终端结点：度！=0的结点
- 内部节点：根节点之外的分支节点
- 结点的子树的根称为该结点的**孩子**，该结点称为孩子的**双亲**
- 兄弟结点：有共同双亲的结点
- 堂兄弟结点：双亲在同一层的结点
- 结点的祖先：从根到该节点所经分支上的任一结点
- 结点的子孙：以该结点为根的子树中的任一结点
- 树的深度：树中结点的最大层次
- 有序树：树中结点的各子树从左至右有次序（最左边为第一个孩子）
- 无序树：树中结点的各子树无次序
- 森林：m(m>=0)棵互不相交的树的集合
  - 把树的结点删除，树就变成了森林
  - 给森林中的各子树加上一个双亲结点，森林就变成了树
  - 一棵树可以看作是一个特殊的森林
  - 树一定是森林，森林不一定是树


### 3.二叉树的定义

- 二叉树是n(n>=0)个结点的有限集，它由空集或由一个根结点及两颗互不相交的分别称为左子树和右子树的二叉树组成
  - 特点：
    1. 每个结点最多有两个孩子（二叉树中不存在在度大于2的结点）
    2. 子树有左右之分，次序不能颠倒
    3. 二叉树可以是空集，根可以有空的左子树或空的右子树
  - 注意：二叉树不是树的特殊情况，它们是两个概念
    - 二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要说明它是左子树还是右子树
    - 树当结点只有一个孩子是，无须区分它是左是右
    - ed：具有三个结点的二叉树有5种不同形态，普通树则只有两种不同形态

- 为什么要重点研究二叉树？
  - 普通树若不转化为二叉树，则运算很难实现
  - 二叉树结构最简单，规律性最强
  - 所有的树都可以转化成唯一对应的二叉树，不失一般性

## （二）案例引入

### 案例一：数据压缩问题

- 将数据文件转换成由0、1组成的二进制编码

### 案例二：利用二叉树求解表达式的值

- 

## （三）树和二叉树的抽象数据类型定义

- ```c
  ADT BinaryTree
  {
      数据对象：D是具有相同特性的数据元素的集合
      数据关系：若D=Ø，则R=Ø;
          	 若D!=Ø,则R={H};H是如下二元关系：
                   1.//关于树的说明
                   2.//关于子树不相交的说明
                   3.//关于数据元素的说明
                   4.//关于左子树和右子树的说明
      基本操作P：  
               CreateBiTree(&T,definition);//建立二叉树
      		PreOrderTraverse(T);//先序遍历
      		InOrderTraverse(T);//中序遍历
      		PostOrderTraverse(T);//后序遍历
      		......
  }ADT BinaryTree
  ```

## （四）二叉树的性质和存储结构

### 1.二叉树的性质（1，2，3）

1. 在二叉树的第i层上至多有2的i-1次方个结点（第1层：2的0次方；第2层：2的1次方）
2. 深度为k的结点至多有2的k次方减1个结点（等比数列），至少有k个结点
3. 对任何一颗二叉树T，如果其叶子节点为n0,度为2的结点个数为n2，则n0=n2+1   （？？？）

### 2.两种特殊的二叉树

#### （1）.满二叉树

- 定义：一棵深度为k，且有2的k次方减1个结点的二叉树
- 特点：
  1. 每一层上的结点数都是最大结点数
  2. 叶子结点全部在最底层
- 对满二叉树结点位置进行编号：
  - 编号规则：从根节点开始，自上而下，自左至右
  - 每一个结点位置都有元素
- 满二叉树在同样深度的二叉树中结点个数最多，叶子结点个数也最多

#### （2）.完全二叉树

- 深度为k的具有n个结点的二叉树，当且仅当其每个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树
- 注：在满二叉树中，从最后一个结点开始，*连续*去掉任意个结点，得到的就是一棵完全二叉树
- 特点：
  1. 叶子结点只可能分布在层次最大的两层上
  2. 对任一结点，如果其右子树的最大层次为i，则其左子树最大层次必为i或i-1
- 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

### 3.完全二叉树的性质（4，5）

4. 具有n个结点的完全二叉树的深度为：（不大于logn的最大整数+1）
5. 完全二叉树中双亲结点编号与孩子结点的编号之间的关系，如果对一棵有n个结点的完全二叉树的结点按层序编号，则对任一结点：
   1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点：（不大于i/2的 最大整数)
   2. 如果2i>n，则结点i是叶子结点，无左孩子；否则，其左孩子是结点：2i
   3. 如果2i+1>n，则结点i无右孩子；否则，其右孩子是结点2i+1

### 4.二叉树的顺序存储

- 实现：按二叉树的结点层次编号，依次存放二叉树中的数据元素

  - ```c
    #define MAXSIZE 100
    typedef TElemType SqBiTree[MAXSIZE];
    SqBiTree bt;
    ```

- 二叉树顺序存储缺点：

  - 最坏情况：深度为k且只有k个结点的单支树，需要2的k次方减1的一维数组

- 特点：结点关系蕴含在其存储位置中，浪费空间，适合满二叉树和完全二叉树

### 5.二叉树的链式存储结构

#### (1). 二叉链表

- 二叉链表中空指针域的数量（假设n个结点）
  - 具有n个结点的二叉链表中，一共有2n个指针域；n个结点一共有n-1个孩子，即有n-1个指针用来指向结点的左右孩子，其余n+1个指针域为空

- ```c
  //二叉链表
  typedef struct BiNode
  {
      TElemType data;
      struct BiNode *lchild,*rchild;//左右孩子指针
  }BiNode,*BiTree;
  ```

#### (2).三叉链表

- ```c
  //三叉链表
  typedef struct TriTNode
  {
      TElemType data;
      struct TriTNode *lchild,*parent *rchild;
  }TriTNode,*TriTree;
  ```

## （五）遍历二叉树和线索二叉树

### 1.遍历的定义：

- 顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅访问一次

### 2.遍历的目的：

- 得到树中所有结点的一个线性排列

### 3.遍历的用途：

- 树结构的插入、删除、修改、查找和排序的前提，是二叉树一切运算的基础和核心

### 4.遍历二叉树算法描述：

- 根结点（D）
- 左子树（L）
- 右子树（R）

#### (1).DLR---先序遍历

- 若二叉树为空，则空操作；否则：
  1. 访问根节点
  2. 先序遍历左子树
  3. 先序遍历右子树
  
- 先序遍历算法(递归实现)

  - ```c
    Status PreOrderTraverse(BiTree T)
    {
        if(T == NULL)
            return OK;//空二叉树
        visit(T);//访问根节点，可以是输出或其他操作
        PreOrderTraverse(T->lchild);//递归遍历左子树
        PreOrderTraverse(T->rchild);//递归遍历右子树
        return OK;
    }
    ```

#### (2).LDR---中序遍历

- 若二叉树为空，则空操作；否则：
  1. 中序遍历左子树
  2. 访问根节点
  3. 中序遍历右子树
  
- 中序遍历算法(递归实现)

  - ```c
    Status InOrderTraverse(BiTree T)
    {
        if(T == NULL)
            return OK;//空二叉树
        InOrderTraverse(T->lchild);//递归遍历左子树
        visit(T);//访问根节点，可以是输出或其他操作
        InOrderTraverse(T->rchild);//递归遍历右子树
        return OK;
    }
    ```

- 中序遍历算法（非递归算法)

  - 基本思想：

    1. 建立一个栈
    2. 根结点进栈，遍历左子树
    3. 根结点出栈，输出根结点，遍历右子树

  - ```c
    Status InorderTraverse(BiTree T)
    {
        BiTree p,q;
        InitStack(S);
        p=T;//p指向根结点
        while(p || !StackEmpty(S)) //树不为空，或栈不为空，终止条件为树和栈都空
        {
            if(p)//根结点不为空
            {
                Push(S,p);//根结点入栈
                p=p->lchild;//指针指向左子树根结点，开始遍历左子树
            }
            else//根结点为空
            {
                Pop(S,q);//根结点出栈
                visit(q);//访问根结点
                p=q->rchild;//指针指向右子树根结点
            }
        }
        return OK;
    }
    ```

#### (3).LRD---后序遍历

- 若二叉树为空，则空操作；否则：
  1. 后序遍历左子树
  2. 后序遍历右子树
  3. 访问根节点
  
- 后序遍历算法(递归实现)

  - ```c
    Status PostOrderTraverse(BiTree T)
    {
        if(T == NULL)
            return OK;//空二叉树
        PostOrderTraverse(T->lchild);//递归遍历左子树
        PostOrderTraverse(T->rchild);//递归遍历右子树
        visit(T);//访问根节点，可以是输出或其他操作
        return OK;
    }
    ```

#### (4).层次遍历

- 对于一棵二叉树，从根节点开始，从上到下，从左到右的顺序访问每一个结点，且每个结点仅访问一次

- 算法设计思路：

  1. 将根结点入队
  2. 队不空时循环：从队列中出列一个结点*p，访问它：
     1. 若它有左孩子结点，将左孩子结点入队
     2. 若它有右孩子结点，将右孩子入队

- ```c
  //队列类型定义
  typedef struct
  {
      BTNode data[MAXSIZE];
      int front,rear;
  }SqQueue;
  //层次遍历算法
  void LevelOrder(BTNode *b)
  {
      BTNode *p;
      SqQueue *b;
      InitQueue(qu);//初始化队列
      enQueue(qu,b);//根结点指针入队
      while(!QueueEmpty(qu))
      {
          deQueue(qu,p);//根结点出队
          visit(p);
          if(p->lchild != NULL)
              enQueue(qu,p->lchild);//有左孩子时将其入队
          if(p->rchild != NULL)
              enQueue(qu,p->rchild);//有右孩子时将其入队
      }
  }
  ```

### 5.二叉树的建立（按先序序列建立）

- 步骤：

  1. 键盘输入二叉树的结点信息，建立二叉树的存储结构
  2. 在建立二叉树的过程中按照二叉树先序的方式建立

- 类C代码：

  - ```c
    Status CreateBiTree(BiTree &T)
    {
        scanf(&ch);
        if(ch == "#")
        {
            T=NULL;
        }
        else
        {
            T=(BiTNode*)malloc(sizeof(BiTNode));
            if(!T)
                exit(OVERFLOW);
            T->data=ch;
            CreateBiTree(T->lchild);//创建左子树
            CreateBiTree(T->rchild);//创建右子树
        }
        return OK;
    }
    ```

- C语言实现：

  - ```c
    //这里二级指针也没问题，也可以使用C++中的引用，也可以使用将返回值设置为一级指针的方式
    Status CreateBiTree(BiTree* T)
    {
    	int a;
    	scanf("%d", &a);
    	if (a == -1)
    	{
    		(*T) = NULL;
    		return OK;
    	}
    	(*T) = (BiTNode*)malloc(sizeof(BiTNode));
    	(*T)->data = a;
    	CreateBiTree(&(*T)->lchild); //创建左子树
    	CreateBiTree(&(*T)->rchild); //创建右子树
    
    	return OK;
    }
    ```


### 6.复制二叉树

- 如果是空树，递归结束；否则：

  - 申请新结点空间
  - 复制根结点
  - 递归复制左子树
  - 递归复制右子树

- 类C代码：

  - ```c
    int Copy(BiTree T,BiTree &NewT)
    {
        if(T == NULL)	//如果是空树，递归结束
        {
            NewT=NULL;
            return 0;
        }
        else
        {
            NewT=(BiTNode*)malloc(sizeof(BiTNode));	//申请新结点空间
            NewT->data=T->data;	//复制根结点
            Copy(T->lchild,NewT->lchild);	//递归复制左子树
            Copy(T->rchild,NewT->rchild);	//递归复制右子树
        }
        return OK;
    }
    ```

- C语言实现：

  - ```c
    int Copy(BiTree T, BiTree* NewT)
    {
    	if (T == NULL)	//如果是空树，递归结束
    	{
    		*NewT = NULL;
    		return 0;
    	}
    	else
    	{
    		*NewT = (BiTNode*)malloc(sizeof(BiTNode));	//申请新结点空间
    		(*NewT)->data = T->data;	//复制根结点
    		Copy(T->lchild, &((*NewT)->lchild));	//递归复制左子树
    		Copy(T->rchild, &((*NewT)->rchild));	//递归复制右子树
    	}
    	return OK;
    }
    ```


### 7.计算二叉树的深度

- 算法思想：

  - 如果是空树，则深度为零
  - 否则，递归计算左子树的深度m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大值加一

- ```c
  int Depth(BiTree T)
  {
      if(T == NULL)
          return 0;
      m=Depth(T->lchild);	//遍历左子树
      n=Depth(T->rchild);	//遍历右子树
      if(m>n)
          return m+1;
      return n+1;
  }
  ```

### 8.计算二叉树结点总数

- 算法思想：

  - 如果是空树，则结点个数为零
  - 否则，结点个数为：左子树结点个数+右子树结点个数+1

- ```c
  int NodeCount(BiTree T)
  {
      if(T == NULL)
          return 0;
      return NodeCount(T->lchild)+NodeCount(T->rchild)+1;//加一加的是当前作为根结点的结点本身
  }
  ```

### 9.计算二叉树叶子结点总数

- 算法思想：

  - 如果是空树，则叶子结点个数为0
  - 否则，叶子结点总数为：左子树叶子结点个数+右子树叶子结点个数

- ```c
  int LeafCount(BiTree T)
  {
      if(T == NULL)
          return 0;
      if(T->lchild==NULL && T->rchild==NULL)
          return 1;//是叶子节点
      return LeafCount(T->lchild)+LeafCount(T->rchild);	//不是叶子节点，则分别统计左右子树叶子结点个数
  }
  ```

### 二叉树完整代码

- 调试很久，问题出在，TElemType设置的类型为int类型，也就是说二叉树结点数据域类型也为int，但创建时输入的是char类型，导致运行一直有问题进行不下去

- ```c
  #define _CRT_SECURE_NO_WARNINGS 1
  
  #include<stdio.h>
  #include<stdlib.h>
  
  #define OK 1	//成功标志
  #define  ERROR 0	//失败标志
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int TElemType;
  
  typedef struct BiTNode
  {
  	TElemType data;
  	struct BiTNode *lchild, *rchild;//左右孩子指针
  }BiTNode, *BiTree;
  
  //函数声明
  Status CreateBiTree(BiTree* T);	//先序遍历建立二叉树
  Status PreOrderTraverse(BiTree T);	//先序遍历二叉树
  Status InOrderTraverse(BiTree T);	//中序遍历二叉树
  Status PostOrderTraverse(BiTree T);	//后序遍历二叉树
  int Copy(BiTree T, BiTree* NewT);	//复制二叉树
  int Depth(BiTree T);	//计算二叉树深度
  int NodeCount(BiTree T);	//计算二叉树结点总数
  int LeafCount(BiTree T);	//计算二叉树叶子结点总数
  
  int main()
  {
  	BiTree T;
  	BiTree NewT;
  	int a = 0;
  
  	CreateBiTree(&T);
  
  	printf("先序遍历序列：");
  	PreOrderTraverse(T);
  	printf("\n");
  	printf("中序遍历序列：");
  	InOrderTraverse(T);
  	printf("\n");
  	printf("后序遍历序列：");
  	PostOrderTraverse(T);
  	printf("\n");
  
  	a = Depth(T);
  	printf("二叉树的深度：%d\n", a);
  	a = NodeCount(T);
  	printf("二叉树的结点总数：%d\n", a);
  	a = LeafCount(T);
  	printf("二叉树叶子结点总数：%d\n", a);
  
  	Copy(T, &NewT);
  	printf("复制二叉树的先序遍历序列：");
  	PreOrderTraverse(NewT);
  	printf("\n");
  
  	return 0;
  }
  
  //先序遍历建立二叉树
  /*
  这里二级指针也没问题，也可以使用C++中的引用，也可以使用将返回值设置为一级指针的方式
  */
  Status CreateBiTree(BiTree* T)
  {
  
  	int a;
  	scanf("%d", &a);
  	if (a == -1)
  	{
  		(*T) = NULL;
  		return OK;
  	}
  	(*T) = (BiTNode*)malloc(sizeof(BiTNode));
  	(*T)->data = a;
  	CreateBiTree(&(*T)->lchild); //创建左子树
  	CreateBiTree(&(*T)->rchild); //创建右子树
  
  	return OK;
  }
  
  //先序遍历二叉树
  Status PreOrderTraverse(BiTree T)
  {
  	if (T == NULL)	//空二叉树
  		return OK;
  	printf("%d ", T->data);
  	PreOrderTraverse(T->lchild);//递归遍历左子树
  	PreOrderTraverse(T->rchild);//递归遍历右子树
  	return OK;
  }
  
  //中序遍历二叉树
  Status InOrderTraverse(BiTree T)
  {
  	if (T == NULL)
  		return OK;//空二叉树
  	InOrderTraverse(T->lchild);//递归遍历左子树
  	printf("%d ", T->data);
  	InOrderTraverse(T->rchild);//递归遍历右子树
  	return OK;
  }
  
  //后序遍历二叉树
  Status PostOrderTraverse(BiTree T)
  {
  	if (T == NULL)
  		return OK;//空二叉树
  	PostOrderTraverse(T->lchild);//递归遍历左子树
  	PostOrderTraverse(T->rchild);//递归遍历右子树
  	printf("%d ", T->data);
  }
  
  //复制二叉树
  int Copy(BiTree T, BiTree* NewT)
  {
  	if (T == NULL)	//如果是空树，递归结束
  	{
  		*NewT = NULL;
  		return 0;
  	}
  	else
  	{
  		*NewT = (BiTNode*)malloc(sizeof(BiTNode));	//申请新结点空间
  		(*NewT)->data = T->data;	//复制根结点
  		Copy(T->lchild, &((*NewT)->lchild));	//递归复制左子树
  		Copy(T->rchild, &((*NewT)->rchild));	//递归复制右子树
  	}
  	return OK;
  }
  
  //计算二叉树深度
  int Depth(BiTree T)
  {
  	int m = 0, n = 0;
  	if (T == NULL)
  		return 0;
  	m = Depth(T->lchild);	//遍历左子树
  	n = Depth(T->rchild);	//遍历右子树
  	if (m>n)
  		return m + 1;
  	return n + 1;
  }
  
  //计算二叉树结点总数
  int NodeCount(BiTree T)
  {
  	if (T == NULL)
  		return 0;
  	return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;//加一加的是当前作为根结点的结点本身
  }
  
  //计算二叉树叶子结点总数
  int LeafCount(BiTree T)
  {
  	if (T == NULL)
  		return 0;
  	if (T->lchild == NULL && T->rchild == NULL)
  		return 1;//是叶子节点
  	return LeafCount(T->lchild) + LeafCount(T->rchild);	//不是叶子节点，则分别统计左右子树叶子结点个数
  }
  ```

### 10.根据遍历序列确定二叉树

- 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的。由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以唯一确定一棵二叉树（但由先序序列和后序序列不可以）
  1. 先序和中序
     - 由先序确定根，由中序确定左右子树
  2. 后序和中序
     - 由后序确定根，由中序确定左右子树
     - 后序遍历，根结点必在后序序列尾部

### 11.线索二叉树

- 为什么要研究线索二叉树？

  - 当使用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前驱和后继结点

- 如何寻找特定遍历序列中二叉树结点的前驱和后继？

  - 解决方法：
    1. 通过遍历寻找（费时间）
    2. 再增设前驱、后继指针域（费空间）（增加了存储负担）
    3. 利用二叉链表中的空指针域：
       - 如果某个结点左孩子为空，则将空的左孩子域改为指向其前驱；
       - 如果某个结点右孩子为空，则将空的右孩子域改为指向其后继；
       - 注：这种改变指向的指针称为“线索”，这种加了线索的二叉树称为**线索二叉树**，对二叉树某种遍历次序使其变为线索二叉树的过程叫**线索化**
       - 为区分lchild和rchild 指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定：
         - ltag=0：lchild指向该结点的左孩子
         - ltag=1：lchild指向该结点的前驱
         - rtag=0：rchild指向该结点的右孩子
         - rtag=1：rhild指向该结点的后继

- 线索二叉树结点结构：

  - ```c
    typedef struct BiThrNode
    {
        int data;
        int ltag,rtag;
        struct BiThrNode *lchild,*rchild;
    }BiThrNode,*BiThrTree;
    ```

  - 为避免悬空态，增设了一个头结点

    - ltag=0，lchild指向根结点
    - rtag=1，rchild指向遍历序列的最后一个结点
    - 遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点

## （六）树和森林

### 1.树的存储结构

1. 双亲表示法

   - 实现：

     - 定义数组，存放树的结点，每个结点含两个域：
       - 数据域：存放结点本身信息
       - 双亲域：指示本结点的双亲结点在数组中的位置

   - 特点：找双亲容易，找孩子难

   - 结点结构类型：

     - ```c
       typedef struct PTNode
       {
           TElemType data;
           int parent;//双亲位置域（数组下标）
       }PTNode;
       ```

   - 树结构：

     - ```c
       #define MAX_TREE_SIZE 100
       typedef struct
       {
           PTNode nodes[MAX_TREE_SIZE];
           int r,n;//根结点位置，结点个数
       }PTree;
       ```

2. 孩子链表

   - 把每个结点的孩子结点排列起来，看成一共线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表），而n个头指针又组成一共线性表，用顺序表（含n个元素的结构数组）存储

   - 特点：找孩子容易，找双亲难

   - 孩子结点结构：

     - ```c
       typedef struct CTNode
       {
           int child;
           struct CTNode *next;
       }*ChildPtr;
       ```

   - 双亲结点结构：

     - ```c
       typedef struct
       {
           TElemType data;
           ChildPtr firstchild;//孩子链表头指针
       }CTBox;
       ```

   - 树结构：

     - ```c
       typedef struct
       {
           CTBox nodes[MAX_TREE_SIZE];
           int n,r;结点数和根结点的位置
       }CTree;
       ```

3. 孩子兄弟表示法

   - 又叫二叉树表示法，二叉链表表示法

   - 实现：用二叉链表作为树的结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点

   - 结构：

     - ```c
       typedef struct CSNode
       {
           ElemType data;
           struct CSNode *firstchild,*nextsibling;
       }CSNode,*CSTree;
       ```

### 2. 树和森林的转换

- 将树转化为二叉树进行处理，利用二叉树的算法实现对树的操作

- 由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作媒介则可以导出树与二叉树之间的对应关系

- 给定一棵树，可以找到唯一的一棵二叉树与之对应

#### （1）.将树转换成二叉树：

- 兄弟相连留长子
      1.  加线：在兄弟之间加一连线
          1.  抹线：对每个结点，除了其左孩子外，去除与其余孩子的关系
  
     3. 旋转：以树的根结点为轴心，将整棵树顺时针旋转45°


#### （2）.将二叉树转换成树：

- 左孩右右连双亲，去掉原来右孩线
    1. 加线：若p结点是双亲的左孩子，则将p的右孩子，右孩子的右孩子......沿分支找到所有右孩子，都与p的双亲用线连起来
    1. 抹线：抹掉原二叉树中双亲与右孩子之间的连线
    1. 调整：将结点按层次排列，形成树结构


#### （3）.森林转换成二叉树：

- 树变二叉根相连
  1. 将各棵树分别转换成二叉树
  2. 将每棵树的根结点用线相连
  3. 以第一棵树根结点作为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构

#### （4）.二叉树转换成森林：

- 去掉全部右孩线，孤立二叉再还原
  1. 抹线：将二叉树中根结点与右孩子的连线，及沿右分支搜索到的所有右孩子间的连线全部抹掉，使之变成孤立的二叉树
  2. 还原：将孤立的二叉树还原成树

### 3. 树和森林的遍历

#### （1）.树的遍历（三种方式）

##### a.先根遍历

- 若树不为空，则先访问根结点，然后依次先根遍历各棵子树

##### b.后根遍历

- 若树不为空，则先依次后根遍历各棵子树，然后访问根结点

##### c.层次根遍历

- 若树不为空，则自上而下自左至右访问树中每个结点

#### （2）.森林的遍历

- 将森林看成三部分构成：

  1. 森林中的第一棵树的根结点
  2. 森林中第一棵树的子森林
  3. 森林中其他树的构成的森林

##### a.先序遍历：

  - 若树不为空，则：
    1. 访问森林中第一棵树的根结点
    2. 先序遍历森林中第一棵树的子树森林
    3. 先序遍历森林中（除第一棵树之外），其余树构成的森林
  - 即：依次从左到右对森林中每一棵树进行先根遍历

##### b.中序遍历：

- 若树不为空，则：
  1. 中序遍历森林中第一棵树的子树森林
  2. 访问森林中第一棵树的根结点
  3. 中序遍历森林中（除第一棵树之外），其余树构成的森林
  - 即：依次从左到右对森林中每一棵树进行后根遍历

## （七）哈夫曼树及其应用

### 1.哈夫曼树的基本概念

- 路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径
- 结点的路径长度：两结点间路径上的分支数
- 树的路径长度：从树根到每一个结点的路径长度之和，记作：TL
  - 结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树
- 权：将树中结点赋给一个有着某种含义的值，这个数值称为该结点的权
- 结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积
- 树的带权结点路径长度：树中所有叶子结点的带权路径长度之和，记作WPL
- **哈夫曼树**：
  - 最优树：带权路径长度（WPL)最短的树
  - 最优二叉树：带权路径长度（WPL)最短的二叉树
  - 特点：
    1. 满二叉树不一定是哈夫曼树
    2. 哈夫曼树中权越大的叶子离根越近
    3. 具有相同带权结点的哈夫曼树不唯一

### 2.哈夫曼树的构造算法

- 贪心算法：构造哈夫曼树时首先选择权值最小的叶子结点

- 哈夫曼算法：

  1. 根据n个给定的权值构成n棵二叉树的森林，森林中的每棵树都只有一个对应的带权根结点（构造森林全是根）
  2. 在F中选取两棵根结点的权值最小的树作为左右子树，构建一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和（选用两小造新树）
  3. 在森林中删除这两棵树，同时将新得到的树加入森林中（删除两小添新树）
  4. 重复2、3，直到森林中只有一棵树，这棵树即为哈夫曼树（重复二三剩单树）

- 口诀：

  1. 构造森林全是根
  2. 选用两小造新树
  3. 删除两小添新树
  4. 重复二三剩单树

- 特点：

  1. 哈夫曼树的结点的度为0或2，没有度为1的结点
  2. 包含n个叶子结点的哈夫曼树中共有2n-1个结点（包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个结点）

- 算法实现：

  - 采用顺序存储结构（一维数组）

  - 结点类型定义：

    - ```c
      typedef struct
      {
          int weight;//权重
          int parent,lch,rch;//双亲、左孩子、右孩子结点下标
      }HTNode,*HuffmanTree;
      ```

  - 算法步骤：

    1. 初始化`HT[1......2n-1]`：`lch=rch=parent=0`
    2. 输入初始n个叶子结点：置于 [1......n] 的weight值
    3. 进行以下n-1次合并，依次产生 n-1 个结点`HT[i],i=n+1,...,2n-1`:
       - 在`HT[1,...,i-1]`中挑选两个未被选过（parent==0) 的 weight 最小的两个结点 HT[s1] , HT[s2] , s1 , s2为两个最小结点下标
       - 修改HT[s1]和HT[s2]的的parent值：`HT[s1].parent=i;HT[s2].parent=i`;
       - 修改新产生的HT[i]:
         - HT[i].weight=HT[s1].weight+HT[s2].weight;
         - HT[i].lch=s1;HT[i].rch=s2;
  
  - 算法实现：
  
    - 类C代码：
    
      - ```c
        void CreatHuffmanTree(HuffmanTree HT,int n)
        {
            if(n <= 1)
                return;
            m=2*n-1;	//数组共2n-1个元素
            HT=(HTNode*)malloc((m+1)*sizeof(HTNode));	//0号元素不用
            for(i=1;i<=m;++i)	//初始化
            {
                HT[i].lch=0;
                HT[i].rch=0;
                HT[i].parent=0;
            }
            for(i=1;i<=n;++i)
                ;	//输入前n个元素的weight值，HT[i].weight
            for(i = n+1; i <= m; i++)
            {
                Select(HT,i-1,s1,s2);//写一个函数，实现：在HT[k](1<=k<=i-1)中选择两个其双亲域为0，且权值最小的结点，								并返回它们在HT中的序号s1和s2
                HT[s1].parent=i;
                HT[s2].parent=i;//表示从F中删除s1和s2，其双亲域不为0了
                HT[i].lch=s1;HT[i].rch=s2;//s1和s2分别作为i的左右孩子
                HT[i].weight=HT[s1].weight+HT[s2].weight;//i的权值为左右孩子权值之和  
            }
        }
        ```
    
    - C语言实现：
    
      - ```c
        void CreatHuffmanTree(HuffmanTree* HT, int n)
        {
        	int m = 0;
        	if (n <= 1)
        		return;
        	m = 2 * n - 1;	//数组共2n-1个元素
        	*HT = (HuffmanTree)malloc((m + 1)*sizeof(HTNode));	//0号元素不用
        	for (int i = 1; i <= m; ++i)	//初始化
        	{
        		(*HT)[i].lch = 0;
        		(*HT)[i].rch = 0;
        		(*HT)[i].parent = 0;
        	}
        	for (int i = 1; i <= n; ++i)
        		scanf("%d", &(*HT)[i].weight);	//输入前n个元素的weight值，HT[i].weight
        	for (int i = n + 1; i <= m; i++)
        	{
        		int s1 = 0, s2 = 0;
        		//写一个函数，实现：在HT[k](1 <= k <= i-1)中选择两个其双亲域为0，且权值最小的结点，并返回它们在HT中的序号s1和s2
        		//为什么是 i-1 ，因为一开始 n = i-1，并且每循环一次，都多一个需要比较的结点
        		Select(*HT, i - 1, &s1, &s2);
        		(*HT)[s1].parent = i;
        		(*HT)[s2].parent = i;//表示从F中删除s1和s2，其双亲域不为0了
        		(*HT)[i].lch = s1; 
        		(*HT)[i].rch = s2;//s1和s2分别作为i的左右孩子
        		(*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;//i的权值为左右孩子权值之和  
        	}
        	printf("哈夫曼树为:>\n");
        	printf("下标\t权值\t父结点\t左孩子\t右孩子\n");
        	for (int i = 1; i <= m; i++)
        	{
        		printf("%d\t%d\t%d\t%d\t%d\n", i, (*HT)[i].weight, (*HT)[i].parent, (*HT)[i].lch, (*HT)[i].rch);
        	}
        	printf("\n");	
        }
        ```
    
  
- 哈夫曼树完整代码：

  - ```c
    #define _CRT_SECURE_NO_WARNINGS 1
    
    #include<stdio.h>
    #include<stdlib.h>
    
    #define OK 1	//成功标志
    #define  ERROR 0	//失败标志
    
    typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
    typedef int TElemType;
    
    typedef struct
    {
    	int weight;//权重
    	int parent, lch, rch;//双亲、左孩子、右孩子结点下标
    }HTNode, *HuffmanTree;
    
    void CreatHuffmanTree(HuffmanTree* HT, int n);
    void Select(HuffmanTree HT, int n, int* s1, int* s2);
    
    int main()
    {
    	HuffmanTree HT;
    	CreatHuffmanTree(&HT, 4);
    	return 0;
    }
    
    void CreatHuffmanTree(HuffmanTree* HT, int n)
    {
    	int m = 0;
    	if (n <= 1)
    		return;
    	m = 2 * n - 1;	//数组共2n-1个元素
    	*HT = (HuffmanTree)malloc((m + 1)*sizeof(HTNode));	//0号元素不用
    	for (int i = 1; i <= m; ++i)	//初始化
    	{
    		(*HT)[i].lch = 0;
    		(*HT)[i].rch = 0;
    		(*HT)[i].parent = 0;
    	}
    	for (int i = 1; i <= n; ++i)
    		scanf("%d", &(*HT)[i].weight);	//输入前n个元素的weight值，HT[i].weight
    	for (int i = n + 1; i <= m; i++)
    	{
    		int s1 = 0, s2 = 0;
    		//写一个函数，实现：在HT[k](1 <= k <= i-1)中选择两个其双亲域为0，且权值最小的结点，并返回它们在HT中的序号s1和s2
    		//为什么是 i-1 ，因为一开始 n = i-1，并且每循环一次，都多一个需要比较的结点
    		Select(*HT, i - 1, &s1, &s2);
    		(*HT)[s1].parent = i;
    		(*HT)[s2].parent = i;//表示从F中删除s1和s2，其双亲域不为0了
    		(*HT)[i].lch = s1; 
    		(*HT)[i].rch = s2;//s1和s2分别作为i的左右孩子
    		(*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;//i的权值为左右孩子权值之和  
    	}
    	printf("哈夫曼树为:>\n");
    	printf("下标\t权值\t父结点\t左孩子\t右孩子\n");
    	for (int i = 1; i <= m; i++)
    	{
    		printf("%d\t%d\t%d\t%d\t%d\n", i, (*HT)[i].weight, (*HT)[i].parent, (*HT)[i].lch, (*HT)[i].rch);
    	}
    	printf("\n");
    	
    }
    
    void Select(HuffmanTree HT, int n, int* s1, int* s2)
    {
    	int min;
    	//找第一个最小值
    	for (int i = 1; i <= n; i++)
    	{
    		if (HT[i].parent == 0)
    		{
    			min = i;
    			break;
    		}
    	}
    	for (int i = min + 1; i <= n; i++)
    	{
    		if (HT[i].parent == 0 && HT[i].weight < HT[min].weight)
    			min = i;
    	}
    	*s1 = min; //第一个最小值给s1
    	//找第二个最小值
    	for (int i = 1; i <= n; i++)
    	{
    		if (HT[i].parent == 0 && i != *s1)
    		{
    			min = i;
    			break;
    		}
    	}
    	for (int i = min + 1; i <= n; i++)
    	{
    		if (HT[i].parent == 0 && HT[i].weight < HT[min].weight&&i != *s1)
    			min = i;
    	}
    	*s2 = min; //第二个最小值给s2
    }
    
    ```

### 3.哈夫曼编码

#### （1）.哈夫曼编码思想

##### 哈夫曼编码

1. 统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）
2. 利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短
3. 在哈夫曼树上标0或1：
   1. 结点的左分支标0，右分支标1
   2. 把从根到每个叶子上的路径上的标号连接起来，作为该叶子结点代表的字符编码

##### 问题1：为什么哈夫曼编码能够保证是前缀编码？

- 因为没有一片树叶是另一片树叶的祖先，所以每个叶子结点的编码就不可能是其他叶子结点编码的前缀

##### 问题2：为什么哈夫曼编码能够保证字符编码总长度最短？

因为哈夫曼树的带权路径长度最短，故字符编码长度最短

##### 性质：

1. 哈夫曼编码是前缀码
2. 哈夫曼编码是最优前缀码

#### （2）.哈夫曼编码的算法实现（？？？较复杂，未理清思路）

- ```c
  void CreatHuffmanCode(HuffmanTree HT,HuffmanCode &HC,int n)
  {
      //从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中
      HC=(char*)malloc((n+1)*sizeof(char));//分配n个字符编码的头指针矢量
      cd=(char*)malloc(n*sizeof(char));//分配临时存放编码的动态数组空间
      cd[n-1]='\0';//编码结束符
      for(i=1;i<=n;++i)//逐个字符求哈夫曼编码
      {
          start=n-1；
          c=i;
          f=HT[i].parent;
          while(f!=0)//从叶子结点开始向上回溯，直到根结点
          {
              --start;//回溯一次start指向前一个位置
              if(HT[f].lchild==c)
                  cd[start]='0';//结点c是f的左孩子，则生成代码0
              if(HT[f].rchild==c)
                  cd[start]='1';//结点c是f的右孩子，则生成代码1
              c=f;
              f=HT[f].parent;//继续向上回溯
          }
          HT[i]=(char*)malloc((n-start)*sizeof(char));//为第i个字符串编码分配空间
          strcpy(HC[i],&cd[start]);//将求的的编码从临时空间cd复制到HC的当前行中
      }
      free(cd);//释放临时空间
  }
  ```

#### （3）.文件的编码和译码

##### a.编码

1. 输入各字符及其权值
2. 构造哈夫曼树`HT[i]`
3. 构造哈夫曼编码`HC[i]`
4. 查HC[i],得到个字符的哈夫曼编码

##### b.译码

1. 构造哈夫曼树`HT[i]`
2. 依次读入二进制码
3. 读入0，则走向左孩子；读入1，则走向右孩子
4. 一旦到达某叶子，即可译出字符
5. 然后再从根出发继续译码，直到结束

- 存在问题：哈夫曼树不唯一，编码也不唯一，译码同样不唯一，是否还要约定更详细的构造哈夫曼树的规则
  - 例如：选用两小造新树时，是否约定更小的在左边；两小相同时，哪一个在左哪一个在右

### 哈夫曼树及哈夫曼编码完整代码

- ```c
  #define _CRT_SECURE_NO_WARNINGS 1
  
  #include<stdio.h>
  #include<stdlib.h>
  #include<string.h>
  
  #define OK 1	//成功标志
  #define  ERROR 0	//失败标志
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int TElemType;
  
  typedef struct
  {
  	int weight;//权重
  	int parent, lch, rch;//双亲、左孩子、右孩子结点下标
  }HTNode, *HuffmanTree;
  
  typedef char** HuffmanCode; //指针数组中存储的元素类型
  
  void CreatHuffmanTree(HuffmanTree* HT, int n);
  void Select(HuffmanTree HT, int n, int* s1, int* s2);
  void HuffCoding(HuffmanTree* HT, HuffmanCode* HC, int n);
  
  int main()
  {
  	HuffmanTree HT;
  	int n = 0;
  	HuffmanCode HC;
  	printf("请输入给定的权值数量：");
  	scanf("%d", &n);
  	CreatHuffmanTree(&HT, n);
  
  	
  	HuffCoding(&HT, &HC, n); //构建哈夫曼编码
  	for (int i = 1; i <= n; i++) //打印哈夫曼编码
  	{
  		printf("数据 %d 的编码为:%s\n", HT[i].weight, HC[i]);
  	}
  
  	return 0;
  }
  
  void CreatHuffmanTree(HuffmanTree* HT, int n)
  {
  	int m = 0;
  	if (n <= 1)
  		return;
  	m = 2 * n - 1;	//数组共2n-1个元素
  	*HT = (HuffmanTree)malloc((m + 1)*sizeof(HTNode));	//0号元素不用
  	for (int i = 1; i <= m; ++i)	//初始化
  	{
  		(*HT)[i].lch = 0;
  		(*HT)[i].rch = 0;
  		(*HT)[i].parent = 0;
  	}
  	printf("请输入所有结点的权值大小：");
  	for (int i = 1; i <= n; ++i)
  	{
  		scanf("%d", &(*HT)[i].weight);	//输入前n个元素的weight值，HT[i].weight
  	}
  	for (int i = n + 1; i <= m; i++)
  	{
  		int s1 = 0, s2 = 0;
  		//写一个函数，实现：在HT[k](1 <= k <= i-1)中选择两个其双亲域为0，且权值最小的结点，并返回它们在HT中的序号s1和s2
  		//为什么是 i-1 ，因为一开始 n = i-1，并且每循环一次，都多一个需要比较的结点
  		Select(*HT, i - 1, &s1, &s2);
  		(*HT)[s1].parent = i;
  		(*HT)[s2].parent = i;//表示从F中删除s1和s2，其双亲域不为0了
  		(*HT)[i].lch = s1; 
  		(*HT)[i].rch = s2;//s1和s2分别作为i的左右孩子
  		(*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;//i的权值为左右孩子权值之和  
  	}
  	printf("哈夫曼树为:\n");
  	printf("下标\t权值\t父结点\t左孩子\t右孩子\n");
  	for (int i = 1; i <= m; i++)
  	{
  		printf("%d\t%d\t%d\t%d\t%d\n", i, (*HT)[i].weight, (*HT)[i].parent, (*HT)[i].lch, (*HT)[i].rch);
  	}
  	printf("\n");
  	
  }
  
  void Select(HuffmanTree HT, int n, int* s1, int* s2)
  {
  	int min;
  	//找第一个最小值
  	for (int i = 1; i <= n; i++)
  	{
  		if (HT[i].parent == 0)
  		{
  			min = i;
  			break;
  		}
  	}
  	for (int i = min + 1; i <= n; i++)
  	{
  		if (HT[i].parent == 0 && HT[i].weight < HT[min].weight)
  			min = i;
  	}
  	*s1 = min; //第一个最小值给s1
  	//找第二个最小值
  	for (int i = 1; i <= n; i++)
  	{
  		if (HT[i].parent == 0 && i != *s1)
  		{
  			min = i;
  			break;
  		}
  	}
  	for (int i = min + 1; i <= n; i++)
  	{
  		if (HT[i].parent == 0 && HT[i].weight < HT[min].weight&&i != *s1)
  			min = i;
  	}
  	*s2 = min; //第二个最小值给s2
  }
  
  //生成哈夫曼编码
  void HuffCoding(HuffmanTree* HT, HuffmanCode* HC, int n)
  {
  	*HC = (HuffmanCode)malloc(sizeof(char*)*(n + 1)); //开n+1个空间，因为下标为0的空间不用
  	char* code = (char*)malloc(sizeof(char)*n); //辅助空间，编码最长为n(最长时，前n-1个用于存储数据，最后1个用于存放'\0')
  	code[n - 1] = '\0'; //辅助空间最后一个位置为'\0'
  	for (int i = 1; i <= n; i++)
  	{
  		int start = n - 1; //每次生成数据的哈夫曼编码之前，先将start指针指向'\0'
  		int c = i; //正在进行的第i个数据的编码
  		int p = (*HT)[c].parent; //找到该数据的父结点
  		while (p) //直到父结点为0，即父结点为根结点时，停止
  		{
  			if ((*HT)[p].lch == c) //如果该结点是其父结点的左孩子，则编码为0，否则为1
  				code[--start] = '0';
  			else
  				code[--start] = '1';
  			c = p; //继续往上进行编码
  			p = (*HT)[c].parent; //c的父结点
  		}
  		(*HC)[i] = (char*)malloc(sizeof(char)*(n - start)); //开辟用于存储编码的内存空间
  		strcpy((*HC)[i], &code[start]); //将编码拷贝到字符指针数组中的相应位置
  	}
  	free(code); //释放辅助空间
  }
  ```

# 六.图

## （一）.图的定义和基本术语

- 图：G=(V，E)			Graph=（Vertex，Edge）
  - V：顶点（数据元素）的有穷非空集合
  - E：边的有穷集合
  
- 无向图：每条边都是没有方向的

- 有向图：每条边都是有方向的

- 完全图：任意两个点都有一条边相连

  - 无向完全图：n 个顶点，有`n(n-1)/2`条边
  - 有向完全图：n 个顶点，有`n(n-1)`条边

- 稀疏图：有很少边或弧的图（e < nlogn)

- 稠密图：有较多边或弧的图

- 网：边/弧带权的图

- 邻接：有边/弧相连的两个顶点之间的关系

  - 存在 `(vi,vj)` ，圆括号表示没有先后关系、是无向的，则称 vi 和 vj 互为邻接点
  - 存在 `<vi,vj>`，尖括号表示有先后关系、是有向的，则称 vi 邻接到 vj ，vj 邻接于 vi

- 关联（依附）：边/弧与顶点之间的关系

  - 存在`(vi,vj) / <vi,vj>`，则称该边/弧关联于 vi 和 vj

- 顶点的度：与该顶点相关联的数目，记为 TD(v)

  - 在有向图中，顶点的度等于顶点的入度和出度之和
  - 顶点的入度是以 v 为终点的有向边的条数，记作 ID(v)
  - 顶点的出度是以 v 为始点的有向边的条数，记作 OD(v)

- 路径：接续的边构成的顶点序列

- 路径长度：路径上边或弧的数目/权值之和

- 回路（环）：第一个顶点和最后一个顶点相同的路径

- 简单路径：除路径起点和终点可以相同外，其余顶点均不相同

- 简单回路（简单环）：除路径起点和终点0相同外，其余顶点均不相同

- 连通图（强连通图）：在无（有）向图中，若对任何两个顶点v、u都存在从 v 到 u 的路径，则称 G 是连通图（强连通图）

- 权和网：图中边或弧所具有的相关数称为权，表明从一个顶点到另一个顶点的距离或耗费

- 子图：设有两个图 G = ( V , { E })、G1 = ( V1 , {E1}) ，若 V1属于 V，E1 属于 E，则称 G1 是 G 的子图

- 连通分量（强连通分量）：

  - 无向图的 G 的**极大连通子图**称为 G 的连通分量
    - 极大连通子图：该子图是G的连通子图，将G的任何不在该子图中的顶点加入，子图不再连通

  - 有向图的 G 的**极大连通子图**称为 G 的强连通分量

- 极小连通子图：该子图是G的连通子图，将G的任何一个顶点删除，子图不再连通

- 生成树：包含无向图 G 的所有顶点的极小连通子图

- 生成森林：对非连通图：由各个连通分量的生成树的集合

  

## （二）.案例引入

### 案例一：六度空间理论

## （三）.图的类型定义

### 1.图的抽象数据类型

- ```c
  
  ```

## （四）.图的存储结构

- 图的逻辑结构：多对多
- 图没有顺序存储结构，但可以借助二维数组来表示元素之间的关系，称为**数组表示法**、或**邻接矩阵**
- 图的链式存储结构：
  - 多重链表：
    - 邻接表
    - 邻接多重表
    - 十字链表

### 1.邻接矩阵

#### 无向图的邻接矩阵

- 建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间的关系）

  - 设图 A = ( V , E ) 有 n 个顶点，顶点表：

  - | i       | 0    | 1    | 2    | ...  | n-1  |
    | ------- | ---- | ---- | ---- | ---- | ---- |
    | Vexs[i] | v1   | v2   | v3   | ...  | vn   |

  - 图的邻接矩阵是一个二维数组 `A.arcs[n][n]`，定义为：

    -  `A.arcs[n][n]`=
      - 1 ，如果 < i , j > 属于 E ，或( i , j ) 属于 E
      - 0

- 分析：

  - 无向图的邻接矩阵是对称的
  - 顶点 i 的度 = 第 i 行（列）中1的个数
  - 完全图的邻接矩阵中，对角元素为0，其余全为1

#### 有向图和邻接矩阵

- 在有向图的邻接矩阵中：
  - 第 i 行的含义：以结点 vi 为尾的弧（出度边）
  - 第 i 列的含义：以结点 vi 为头的弧（入度边）
- 分析：
  - 有向图的邻接矩阵可能不是对称的
  - 顶点的出度 = 第 i 行元素之和
  - 顶点的入度 = 第 i 列元素之和
  - 顶点的度 = 第 i 行元素和第 i 列元素之和

#### 网的邻接矩阵

-  `A.arcs[i][j]`=
  - Wij ，如果 < vi , vj > 属于 VR，或( vi , vj ) 属于 VR
  - ∞

#### 算法：采用邻接矩阵表示法创建无向网

##### 邻接矩阵的存储表示

- 用两个数组分别存储定点表和邻接矩阵

- ```c
  #define MaxInt 32767	//表示极大值∞
  #define MVNum 100	//最大顶点数
  typedef char VerTexType;	//设顶点的数据类型为字符型
  typedef int ArcType;	//假设边的权值类型为整型
  typedef struct
  {
      VerTexType vexs[MVNum];	//顶点表
      ArcType arcs[MVNum][MVNum];	//邻接矩阵
      int vexnum, arcnum;	//图的当前顶点数和边数
  }AMGraph;	//Adjacency Matrix Graph
  ```

##### 算法思想

1. 输入总顶点数和总边数
2. 依次输入顶点的信息存入顶点表中
3. 初始化邻接矩阵，使每个权值初始化为极大值（使用双重循环）
4. 构造邻接矩阵

- 不同点：
  - 无向网
    - 无向图：初始化邻接矩阵时，w均为0；构造邻接矩阵时，w均为1
  - 有向网：仅为`G.arcs[i][j]`赋值，不为对称边赋值
    - 有向图：结合以上两处更改

##### 代码实现

- 类C代码：

  - ```c
    Status CreateUDN(AMGraph &G)
    {
        cin >> G.vexnum >> G.arcnum;	//输入总顶点数、总边数
        for(i = 0; i < G.vexnum; i++)
        {
            cin >> G.vexs[i];	//依次输入点的信息
        }
        for(i = 0; i < G.vexnum; i++)
        {
            for(j = 0; j < G.vexnum; j++)
            {
                G.arcs[i][j] = MaxInt;	//初始化每个权值为极大值
            }
        }
        for(k = 0; k < G.arcnum; k++)
        {
            cin >> v1 >> v2 >> w;	//输入一条边所依附的顶点及边的权值
            i = LocateVex(G, v1);
            j = LocateVex(G, v2);	//确定v1、v2在G中的位置
            G.arcs[i][j] = w;	//边<v1,v2>的权置为w
            G.arcs[j][i] = G.arcs[i][j];	//将其对称边的权值也置为w
        }
        return OK;
    }
    
    //查找顶点下标
    int LocateVex(AMGraph G, VerTexType v)
    {
        int i;
        for(i = 0; i < G.vexnum; i++)
        {
            if(v == G.vexs[i])
            {
                return i;
            }
        }
        return -1;
    }
    ```

##### 邻接矩阵表示法的优缺点

- 优点：

  - 直观、简单、好理解

  - 方便检查任意一对顶点之间是否存在边

  - 方便找任一顶点的所有“邻接点”

  - 方便计算任一顶点的度

- 缺点：

  - 不便于增加和删除顶点
  - 若存储稀疏图，有大量无效空间，浪费空间
    - 对稠密图来说还是很合算
  - 浪费时间，统计稀疏图中一共有多少条边

### 2.邻接表

#### 邻接表表示法（链式）

- 头结点：data、firstarc
- 表结点：adjvex（邻接点域：存放与 vi 邻接的顶点在表头数组中的位置）、nextarc（链域：指向下一条边或弧）、info（权值）
- 顶点：按编号顺序将顶点数据存储在一维数组中
- 关联同一顶点的边（以顶点为尾的弧）
  - 用线性链表存储

##### a.无向图的邻接表

- 特点：
  - 邻接表不唯一
  - 若无向图中有 n 个顶点、 e 条边，则其邻接表需 n 个头结点和 2e 个表结点。适宜存储稀疏图
  - 无向图中顶点 vi 的度为第 i 个单链表中的结点数

##### b.有向图的邻接表

- 邻接表：每个头结点存放它的出度边
  - 特点：
    - 顶点 vi 的出度为第 i 个单链表中结点的个数
    - 顶点 vi 的入度为整个单链表中邻接点域是 i-1 的结点个数
    - 找出度易，找入度难
- 逆邻接表：每个头结点存放它的入度边
  - 特点：
    - 顶点 vi 的入度为第 i 个单链表中结点的个数
    - 顶点 vi 的出度为整个单链表中邻接点域是 i-1 的结点个数
    - 找入度易，找出度难

##### c.算法：建立邻接表

- 图的邻接表存储表示

  - ```c
    #define MVNum 100
    typedef char VerTexType;	//设顶点的数据类型为字符型
    typedef struct VNode	//顶点的结构类型
    {
        VerTexType data;	//顶点信息
        ArcNode* firstarc;	//指向第一条依附该结点的边的指针
    }VNode, AdjList[MVNum];	//AdjList表示邻接表类型	 AdjList v; 相当于 VNode v[MVNum];
    typedef struct ArcNode	//边（弧）结点的结构类型
    {
        int adjvex;	//该边所指向的顶点的位置
        struct ArcNode* nextarc;	//指向下一条边的指针
        OtherInfo info;	//和边相关的信息（权值）
    }ArcNode;
    typedef struct
    {
        AdjList vertices;	//顶点数组
        int vexnum, arcnum;	//顶点数和边（弧）数
    }ALGraph;
    ```

- 采用邻接表表示法创建无向网：

  - 算法思想：

    1. 输入总顶点数和边数

    2. 建立顶点表

       - 依次输入点的信息存入顶点表中

       - 使每个表头结点的指针域初始化为NULL
    3. 创建邻接表

       - 依次输入每条边依附的两个顶点，确定两个顶点的序号 i 和 j ，建立边结点
    
       - 将此边结点分别插入到 vi 和 vj 对应的两个边链表的头部（有向网时不需要直接复制插入另一个）
    
  - ```c
    Status CreateUDG(ALGraph &G)
    {
        cin >> G.vexnum >> G.arcnum;	//输入总顶点数、总边数
        for(i = 0; i < G.vexnum; i++)
        {
            cin >> G.vertices[i].data;	//输入顶点值
            G.vertices[i].firstarc = NULL;	//初始化表头结点的指针域
        }
        for(k = 0; k < G.arcnum; k++)
        {
            cin >> v1 >> v2;	//输入一条边依附的两个顶点
            i = LocateVex(G, v1);
            j = LocateVex(G, v2);
            p1 = new ArcsNode;	//生成一个新的边结点
            p1->adjvex = j;	//邻接点序号为j
            p1 -> nextarc = G.vertices[i].firstarc;	//头插法插入结点
            G.vertices[i].firstarc = p1;	//将新结点p1插入顶点 vi 的边表头部
            //反过来还有一条边
            p2 = new ArcNode;	//生成一个新的边结点
            p2->adjvex = i;	//邻接点序号为i
            p2 -> nextarc = G.vertices[j].firstarc;	//头插法插入结点
            G.vertices[j].firstarc = p2;	//将新结点p2插入顶点 vj 的边表头部
        }
        return OK;
    }
    
    //查找顶点下标
    int LocateVex(ALGraph G, VerTexType v)
    {
        int i;
        for(i = 0; i < G.vexnum; i++)
        {
            if(v == G.vertices[i].data)
            {
                return i;
            }
        }
        return -1;
    }
    ```

##### d.邻接表表示法的优缺点以及与邻接矩阵的关系

###### 邻接表表示法的优缺点

- 优点：
  - 方便找任一顶点的所有邻接点
  - 节约稀疏图的空间
    - 需要 N 个头指针 + 2E 个结点
  - 方便计算任一顶点的度
    - 对无向图：是的
    - 对有向图：只能计算出度；需要构造逆邻接表才能方便计算出度
- 缺点：
  - 不方便检查任一一对顶点之间是否存在边

###### 邻接表表示法与邻接矩阵的关系

- 联系：
  - 在邻接表中每个链表对应邻接矩阵中的一行，链表中结点个数等于矩阵中一行中的非零元素个数
- 区别：
  - 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）
  - 邻接矩阵的空间复杂度是O(N^2)，而邻接表的空间复杂度为O(N + e)
- 用途：
  - 邻接表多用于稀疏图
  - 邻接矩阵多用于稠密图

### 3.十字链表

- 邻接表的缺点：
  - 有向图：求结点的度困难（改进：十字链表）
  - 无向图：每条边都要存储两边（改进：邻接多重表）

## （五）.图的遍历

### 1.遍历的定义

- 从已给的连通图中某一顶点出发，沿着一些边访遍图中所有顶点，且每个顶点仅被访问一次

### 2.遍历的实质

- 找每个结点的邻接点的过程

### 3.图的特点

- 图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点
### 4.怎么能避免重复访问？
  - 解决思路：设置辅助数组`visited[n]`，用来标记每个被访问过的顶点
    - 初始状态`visited[i] = 0`
    - 顶点 i 被访问，改`visited[i]`为1，防止被多次访问


### 5.图常用的遍历

- 深度优先搜索（Depth_First Search --- DFS）
- 广度优先搜索（Breadth_First Search --- BFS）

### 6.深度优先遍历（DFS）

#### （1）方法：

- 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1
- 再从 w1 出发，访问与 w1 邻接但还未访问过的顶点 w2
- 然后再从 w2 出发，进行类似的访问
- 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止
- 接着，退回一步，推到前一次访问过的顶点，看是否还有其它没有被访问过的邻接顶点
- 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问
- 如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止
  - 连通图的深度优先遍历类似于树的先跟遍历

#### （2）深度优先遍历算法的实现

##### 邻接矩阵上的深度优先遍历

- ```c
  void DFS(AMGraph G, int v)
  {
      cout << v;
      visited[v] = true;	//记录他改为已被访问
      for(w = 0; w < G.vexnum; w++)
      {
          if((G.arcs[v][w] != 0) && (visited[w] == 0))	//弧存在，且未被访问的邻接顶点
          {
              DFS(G, w);	//w是v的邻接顶点，若w未被访问，则递归调用DFS
          }
      }
  }
  ```

- DFS算法效率分析：

  - 用邻接矩阵表示图，遍历每一个顶点都要从头扫描该顶点所在行，时间复杂度为O(n^2)
  - 用邻接表表示图，虽然有 2e 个表结点，但只需要扫描 e 个结点即可完成遍历，加上访问 n 个头结点的时间，时间复杂度为O(n+e)
  - 结论：
    - 稠密图适用在邻接矩阵上进行深度优先遍历
    - 稀疏图适用在邻接表上进行深度优先遍历

##### 邻接表上的深度优先遍历

### 7.广度优先遍历（BFS）

#### （1）方法：

- 从图的某一顶点出发，首先依次访问该结点的所有邻接顶点
- 再按这些顶点被访问的先后次序依次访问与它们邻接的所有未访问的顶点
- 重复此过程，直到所有顶点均被访问为止

#### （2）算法实现：

- ```c
  //广度优先非递归遍历连通图G
  void BFS(Graph G, int v)
  {
      cout << v;
      vidited[v] = true;	//访问第v个顶点
      InitQueue(Q);	//辅助队列Q初始化，置空
      EnQueue(Q, v);	//v入队
      while(QueueEmpty(Q) != 0)	//队列非空
      {
          DeQueue(Q, u);	//队头元素出队并置为u
          for(w = FirstAdjVex(G, u); w >=0; w = NextAdjVex(G, u, w))
          {
              if(visited[w] != 0)	//w为u的尚未访问的邻接顶点
              {
                  cout << w;
                  visited[w] = true;
                  EnQueue(Q, w);	//w入队
              }
          }
      }
  }
  ```

#### （3）BFS算法效率分析

- 如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（n 个元素），总的时间代价为O(n^2)
- 用邻接表来表示图，虽然有 2e 个表结点，但只需要扫描 e 个结点即可完成遍历，加上访问 n 个头结点的时间，时间复杂度为O(n+e)

### 8.邻接矩阵表示的深度优先遍历和广度优先遍历（C++）

- ```c++
  #define _CRT_SECURE_NO_WARNINGS
  #include<iostream>
  using namespace std;
  
  #define MaxInt 32767	//表示极大值∞
  #define MVNum 100	//最大顶点数
  #define MAXQSIZE 50  //定义队列中元素的最大个数
  #define OK 1	//成功标志
  #define ERROR 0	//失败标志
  #define TRUE 1
  #define FALSE 0
  typedef char VerTexType;	//设顶点的数据类型为字符型
  typedef int ArcType;	//假设边的权值类型为整型
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int QElemType;
  
  //顺序队列
  typedef struct
  {
  	QElemType *base;//初始化动态分配存储空间
  	int front;//头指针（实际是队头元素下标）
  	int rear;//尾指针（实际是队尾元素下标）
  }SqQueue;
  
  //图
  typedef struct
  {
  	VerTexType vexs[MVNum];	//顶点表
  	ArcType arcs[MVNum][MVNum];	//邻接矩阵
  	int vexnum, arcnum;	//图的当前顶点数和边数
  }AMGraph;	//Adjacency Matrix Graph
  
  //函数声明
  int LocateVex(AMGraph G, VerTexType v);	//查找顶点下标
  void CreateUDN(AMGraph &G);	//创建邻接矩阵
  void DFS(AMGraph G, int v);	//深度优先递归遍历
  void BFS(AMGraph G, int v);	//广度优先非递归遍历
  Status InitQueue(SqQueue& Q);	//队列初始化
  Status EnQueue(SqQueue& Q, QElemType e);	//循环队列入队
  Status DeQueue(SqQueue& Q, QElemType& e);	//循环队列出队
  
  int visited[MVNum];
  
  int main()
  {
  	AMGraph G;
  	CreateUDN(G);
  
  	cout << "邻接矩阵：" << endl;
  	for (int i = 0; i < G.vexnum; i++)
  	{
  		for (int j = 0; j < G.vexnum; j++)
  		{
  			cout << G.arcs[i][j] << " ";
  		}
  		cout << endl;
  	}
  	cout << "邻接矩阵深度优先遍历序列：";
  	DFS(G, 0);
  	cout << endl;
  
  	for (int i = 0; i < G.vexnum; i++)	//将标志数组置0
  	{
  		visited[i] = 0;	
  	}
  	cout << "邻接矩阵广度优先遍历序列：";
  	BFS(G, 0);
  	cout << endl;
  	
  	system("pause");
  	return 0;
  }
  
  //查找顶点下标
  int LocateVex(AMGraph G, VerTexType v)
  {
  	int i;
  	for (i = 0; i < G.vexnum; i++)
  	{
  		if (v == G.vexs[i])
  		{
  			return i;
  		}
  	}
  	return -1;
  }
  
  void CreateUDN(AMGraph &G)
  {
  	cout << "输入总顶点数和总边数：";
  	cin >> G.vexnum >> G.arcnum;	//输入总顶点数、总边数
  	cout << "依次输入顶点的信息：";
  	for (int i = 0; i < G.vexnum; i++)
  	{
  		cin >> G.vexs[i];	//依次输入点的信息
  		visited[i] = 0;	//初始化标志数组为0
  	}
  	for (int i = 0; i < G.vexnum; i++)
  	{
  		for (int j = 0; j < G.vexnum; j++)
  		{
  			G.arcs[i][j] = 0;	//初始化每条边权值为0
  		}
  	}
  	cout << "输入一条边所依附的两个顶点及边的权值：";
  	for (int k = 0; k < G.arcnum; k++)
  	{
  		VerTexType v1, v2;
  		int w;
  		cin >> v1 >> v2 >> w;	//输入一条边所依附的顶点及边的权值
  		int i = LocateVex(G, v1);
  		int j = LocateVex(G, v2);	//确定v1、v2在G中的位置
  		G.arcs[i][j] = w;	//边<v1,v2>的权置为w
  		G.arcs[j][i] = w;	//将其对称边的权值也置为w
  	}
  }
  
  //深度优先递归遍历
  void DFS(AMGraph G, int v)
  {
  	cout << G.vexs[v] << " ";
  	visited[v] = 1;	//记录他改为已被访问
  	for (int w = 0; w < G.vexnum; w++)
  	{
  		if ((G.arcs[v][w] != 0) && (visited[w] == 0))	//弧存在，且未被访问的邻接顶点
  		{
  			DFS(G, w);	//w是v的邻接顶点，若w未被访问，则递归调用DFS
  		}
  	}
  }
  
  //广度优先非递归遍历
  void BFS(AMGraph G, int v)
  {
  	cout << G.vexs[v] << " ";	//输出第一个遍历顶点
  	visited[v] = 1;	//记录他改为已被访问
  	SqQueue Q;
  	InitQueue(Q);	//辅助队列Q初始化，置空
  	EnQueue(Q, v);	//v入队
  
  	while (Q.front != Q.rear)	//队列非空
  	{
  		int u = 0;
  		DeQueue(Q, u);	//队头元素出队并置为u
  
  		int w = 0;
  		for (int i = 0; i < G.vexnum; i++)
  		{
  			if ((G.arcs[u][i] != 0) && (visited[i] == 0))
  			{
  				w = i;	//找到u的第一个未被访问的邻接顶点，然后直接跳出
  				break;
  			}
  		}
  		for (; w < G.vexnum; w++)
  		{
  			if ((G.arcs[u][w] != 0) && (visited[w] == 0))	//将u的全部未访问的邻接顶点入队
  			{
  				cout << G.vexs[w] << " ";
  				visited[w] = 1;
  				EnQueue(Q, w);	//w入队
  			}
  		}
  	}
  }
  
  //队列初始化
  Status InitQueue(SqQueue& Q)
  {
  	Q.base = new QElemType[MAXQSIZE];
  	if (!Q.base)
  		return ERROR;
  	Q.front = 0;
  	Q.rear = 0;
  	return OK;
  }
  
  //循环队列入队
  Status EnQueue(SqQueue& Q, QElemType e)
  {
  	if ((Q.rear + 1) % MAXQSIZE == Q.front)		//判断是否出现上溢
  		return ERROR;
  	Q.base[Q.rear] = e;
  	Q.rear = (Q.rear + 1) % MAXQSIZE;
  	return OK;
  }
  
  //循环队列出队
  Status DeQueue(SqQueue& Q, QElemType& e)
  {
  	if (Q.front == Q.rear)	//判断是否出现下溢（队空）
  		return ERROR;
  	e = Q.base[Q.front];
  	Q.front = (Q.front + 1) % MAXQSIZE;
  	return OK;
  }
  ```

### 9.邻接表表示的深度优先遍历和广度优先遍历（C++）

- ```c++
  #define _CRT_SECURE_NO_WARNINGS
  #include<iostream>
  using namespace std;
  
  #define MaxInt 32767	//表示极大值∞
  #define MVNum 100	//最大顶点数
  #define MAXQSIZE 50  //定义队列中元素的最大个数
  #define OK 1	//成功标志
  #define ERROR 0	//失败标志
  #define TRUE 1
  #define FALSE 0
  typedef char VerTexType;	//设顶点的数据类型为字符型
  typedef int ArcType;	//假设边的权值类型为整型
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int QElemType;
  int visited[MVNum];
  
  //顺序队列
  typedef struct
  {
  	QElemType *base;//初始化动态分配存储空间
  	int front;//头指针（实际是队头元素下标）
  	int rear;//尾指针（实际是队尾元素下标）
  }SqQueue;
  
  typedef struct ArcNode	//边（弧）结点的结构类型
  {
  	int adjvex;	//该边所指向的顶点的位置
  	struct ArcNode* nextarc;	//指向下一条边的指针
  
  }ArcNode;
  
  typedef struct VNode	//顶点的结构类型
  {
  	VerTexType data;	//顶点信息
  	ArcNode* firstarc;	//指向第一条依附该结点的边的指针
  }VNode, AdjList[MVNum];	//AdjList表示邻接表类型	 AdjList v; 相当于 VNode v[MVNum];
  
  typedef struct
  {
  	AdjList vertices;	//顶点数组
  	int vexnum, arcnum;	//顶点数和边（弧）数
  }ALGraph;
  
  //函数声明
  void CreateUDG(ALGraph &G);	//创建邻接表
  int LocateVex(ALGraph G, VerTexType v);	//查找顶点下标
  void DFS(ALGraph G, int v);	//深度优先递归遍历
  void BFS(ALGraph G, int v);	//广度优先非递归遍历
  Status InitQueue(SqQueue& Q);	//队列初始化
  Status EnQueue(SqQueue& Q, QElemType e);	//循环队列入队
  Status DeQueue(SqQueue& Q, QElemType& e);	//循环队列出队
  
  int main()
  {
  	ALGraph G;
  	CreateUDG(G);
  
  	for (int i = 0; i < G.vexnum; i++)
  	{
  		visited[i] = 0;
  	}
  	cout << "邻接表深度优先遍历序列：";
  	DFS(G, 0);
  	cout << endl;
  	
  	for (int i = 0; i < G.vexnum; i++)
  	{
  		visited[i] = 0;
  	}
  	cout << "邻接表广度优先遍历序列：";
  	BFS(G, 0);
  	cout << endl;
  
  	system("pause");
  	return 0;
  }
  
  void CreateUDG(ALGraph &G)
  {
  	cout << "输入总顶点数和总边数：";
  	cin >> G.vexnum >> G.arcnum;	//输入总顶点数、总边数
  	cout << "输入各顶点值：";
  	for (int i = 0; i < G.vexnum; i++)
  	{
  		cin >> G.vertices[i].data;	//输入顶点值
  		G.vertices[i].firstarc = NULL;	//初始化表头结点的指针域
  	}
  	cout << "输入一条边所依附的两个顶点：" << endl;
  	for (int k = 0; k < G.arcnum; k++)
  	{
  		char v1, v2;
  		cin >> v1 >> v2;	//输入一条边依附的两个顶点
  		int i = LocateVex(G, v1);
  		int j = LocateVex(G, v2);
  		ArcNode* p1 = new ArcNode;	//生成一个新的边结点
  		p1->adjvex = j;	//邻接点序号为j
  		p1->nextarc = G.vertices[i].firstarc;	//头插法插入结点
  		G.vertices[i].firstarc = p1;	//将新结点p1插入顶点 vi 的边表头部
  		//反过来还有一条边
  		ArcNode* p2 = new ArcNode;	//生成一个新的边结点
  		p2->adjvex = i;	//邻接点序号为i
  		p2->nextarc = G.vertices[j].firstarc;	//头插法插入结点
  		G.vertices[j].firstarc = p2;	//将新结点p2插入顶点 vj 的边表头部
  	}
  }
  
  //查找顶点下标
  int LocateVex(ALGraph G, VerTexType v)
  {
  	int i;
  	for (i = 0; i < G.vexnum; i++)
  	{
  		if (v == G.vertices[i].data)
  		{
  			return i;
  		}
  	}
  	return -1;
  }
  
  //深度优先递归遍历
  void DFS(ALGraph G, int v)
  {
  	cout << G.vertices[v].data << " ";
  	visited[v] = 1;	//记录他改为已被访问
  
  	ArcNode *p = G.vertices[v].firstarc;	//定义一个指针指向顶点
  	while (p != NULL)	//顶点有邻接顶点时
  	{
  		int j = p->adjvex;	//顶点的第一个邻接顶点
  		if (visited[j] == 0)
  		{
  			DFS(G, j);
  		}
  		p = p->nextarc;	
  	}
  }
  
  //广度优先遍历
  void BFS(ALGraph G, int v)
  {
  	cout << G.vertices[v].data << " ";
  	visited[v] = 1;
  	SqQueue Q;
  	InitQueue(Q);
  	EnQueue(Q, v);
  
  	while (Q.front != Q.rear)
  	{
  		int u = 0;
  		DeQueue(Q, u);	//队头元素出队并置为u
  		
  		ArcNode *p = G.vertices[u].firstarc;
  		while (p != NULL)
  		{
  			int j = p->adjvex;
  			if (!visited[j])
  			{
  				cout << G.vertices[j].data << " ";
  				visited[j] = 1;
  				EnQueue(Q, j);	//j入队
  
  			}
  			p = p->nextarc;
  		}
  	}
  }
  
  //队列初始化
  Status InitQueue(SqQueue& Q)
  {
  	Q.base = new QElemType[MAXQSIZE];
  	if (!Q.base)
  		return ERROR;
  	Q.front = 0;
  	Q.rear = 0;
  	return OK;
  }
  
  //循环队列入队
  Status EnQueue(SqQueue& Q, QElemType e)
  {
  	if ((Q.rear + 1) % MAXQSIZE == Q.front)		//判断是否出现上溢
  		return ERROR;
  	Q.base[Q.rear] = e;
  	Q.rear = (Q.rear + 1) % MAXQSIZE;
  	return OK;
  }
  
  //循环队列出队
  Status DeQueue(SqQueue& Q, QElemType& e)
  {
  	if (Q.front == Q.rear)	//判断是否出现下溢（队空）
  		return ERROR;
  	e = Q.base[Q.front];
  	Q.front = (Q.front + 1) % MAXQSIZE;
  	return OK;
  }
  ```

## （六）.图的应用

## （七）.案例分析与实现

# 七.查找

## （一）查找的概念

- 问题：在哪里找？
  - 查找表：查找表是由同一类型的数据元素（或记录）构成的集合。由于集合中的数据元素之间存在松散的关系，因此查找表是一种应用灵便的结构
- 问题：什么查找？
  - 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）
    - 关键字：用来标识一个数据元素（或记录）的某个数据项的值
      - 主关键字：可以唯一标识一个记录的关键字
      - 次关键字：用于识别若干记录的关键字是次关键字
- 问题：成功与否？
  - 若查找表中存在这样一个记录，则“查找成功”
    - 查找成功则给出整个记录的信息，或指示该记录在查找表中的位置
  - 否则“查找不成功”
    - 查找结果给出“空记录”或“空指针”
- 问题：查找目的是什么？
  - 查询某个特定的数据元素是否在查找表中
  - 检索某个特点是数据元素的各种属性
  - 在查找表中插入一个数据元素
  - 删除查找表中某个数据元素
- 问题：查找表怎么分类？
  - 查找表分为两类：
    - 静态查找表：
      - 仅作查询（检索）操作的查找表
    - 动态查找表：
      - 作插入删除操作的查找表
      - 有时查询后还需要将查询结果“不在查找表中”的数据元素插入到查找表中；或者，从查找表中删除其查询结果为“在查找表中”的数据元素
- 问题：如何评价查找算法？
  - 查找算法的评价指标：
    - 关键字的平均比较次数，也称平均查找长度，ASL
- 查找过程中我们要研究什么？
  - 查找方法取决与查找表的结构，即表中数据元素是依何种关系组织在一切的
  - **设法提高查找表的效率**，是本章讨论问题的出发点
  - 为提高查找效率，一个办法就是 **在构造查找表时，在集合中的数据元素人为地加上某种确定的约束关系**

## （二）线性表的查找

### 1.顺序查找（线性查找）

- 顺序查找：在顺序表 ST 中查找值为 key 的数据元素，从最后一个元素开始比较

- 应用范围：

  - 顺序表或线性链表标识的静态查找表
  - 表内元素无序

- 顺序表的标识：

  - 数据元素类型定义：

    - ```c
      typedef struct
      {
          KeyType key;	//关键字域
          ...	//其他域
      }ElemType;
      typedef struct
      {
          ElemType *R;	//表的基地址
          int length;	//表长
      }SStable;	//Sequential Search Table
      SStable ST;	//定义顺序查找表
      ```

#### 算法1：在顺序表 ST 中查找值为 key 的数据元素

  - 类C代码：

    - 原版：

      - ```c
        //若查找成功，则返回其位置信息；否则返回0
        int Search_Seq(SStable ST,KeyType key)
        {
            for(i = ST.length;i >= 1;--i)
            {
                 if(ST.R[i].key == key)
                    return i;
            }       
            return 0;
        }
        ```

    - 其他写法：

      - ```c
        //不推荐
        int Search_Seq(SStable ST,KeyType key)
        {
            for(i = ST.length; ST.R[i].key == key; --i)
            {
                if(i <= 0)
                    break;
            }        
            if(i>0)
            	return i;
            return 0;
        }
        ```
        
      - ```c
        //最简洁写法，但可读性不如原版
        int Search_Seq(SStable ST,KeyType key)
        {
            for(i = ST.length; ST.R[i].key == key && i>0; --i);	//注意这里有分号，for循环内部没有要执行的语句
            return i;
        }
        ```

  - C语言实现（原版）：

    - ```c
      //若查找成功，则返回其位置信息；否则返回0
      int Search_Seq(SStable ST,KeyType key)
      {
          for(int i = ST.length; i >= 1; --i)
          {
               if(ST.R[i].key == key)
                  return i;
          }       
          return 0;
      }
      ```

#### 算法2：增加监视哨的顺序查找

  - 改进：把待查关键字 key 存入表头（“哨兵”，“监视哨”），从后往前逐个比较，可免去查好过程中每一步都要检测是否查找完毕（不需要检查是否越界，将原本每次循环比较两次降低为每次循环只比较一次），可加快速度

  - 当 ST.length 较大时，此改进能使一次查找所需的平均时间几乎减少一半

    - 类C代码：

      - ```c
        int Search_Seq(SStable ST,KeyType key)
        {
            ST.R[0].key = key;
            for(i = ST.length; ST.R[i].key == key; --i);//i=0时一定会等于key,结束循环
            return i;
        }
        ```

    - C语言实现：
    
      - ```c
        int Search_Seq(SStable ST,KeyType key)
        {
            ST.R[0].key = key;
            int i;
            for(i = ST.length; ST.R[i].key == key; --i);//i=0时一定会等于key,结束循环
            return i;
        }
        ```
    
  - 时间效率分析：

    - 比较次数与 key 的位置有关：
        - 查找第 i 个元素，需要比较`n-i+1`次
        - 查找失败，需要比较`n+1`次

    - 时间复杂度：O（n）
        - （n+1）/2

    - 空间复杂度：O（1）

  - 讨论：

    1. 记录的查找概率不相等时如何提高查找效率？
       - 查找表存储记录原则：按查找概率高低存储
           - 查找概率越高，比较次数越少
           - 查找概率越低，比较次数越多

    2. 记录的查找概率无法测定时如何提高查找效率？
       - 按查找概率动态调整记录规则
         1. 在每个记录中设一个访问频度域
         2. 始终保持记录按非递增有序的次序排列
         3. 每次查找后将刚查找到的记录之间移至表头

- 顺序查找的特点：
  - 优点：算法简单，逻辑次序无要求，且不同存储结构均适用
  - 缺点：ASL太长，时间效率太低

### 2.折半查找（二分查找或对分查找）

- 折半查找：每次将待查记录所在区间缩小一半

- 查找过程：

  - low
  - high
  - mid = (low + high) / 2
    - 取整，向下取整。例如：7.5，取7
  - key < mid 则 high = mid  - 1
  - key > mid 则 low = mid + 1
  - key == mid 找到
  - high < low 结束，找不到

- 折半查找算法（非递归算法）

  - 类C代码：

    - ```c
      //设表长为n，low、high和mid分别指向待查元素所在区间的上界。下界和中点，key为给定的要查找的值
      //初始时，令low = 1，high = n，mid = (low + high) / 2
      //让key与mid指向的记录比较：
      //key == R[mid].key，查找成功；
      //key < R[mid].key, high = mid - 1
      //key > R[mid].key, low = mid + 1
      //重复上述操作，直到high < low 结束，找不到
      int Search_Bin(SSTable ST, KeyType key)
      {
          low = 1;high = ST.length;
          while(low <=high)
          {
              mid = (low + high) / 2;
              if(key == ST.R[mid].key)
                  return mid;	//找到
              if(key < ST.R[mid].key)
              {
                  high = mid - 1;	//key在mid左边，在前半区查找
              }
              else
              {
                  low = mid + 1;	//key在mid右边，在后半区查找
              }
          }
          return 0;
      }
      ```

  - C语言实现：

    - ```c
      
      ```

- 折半查找算法（递归算法）

  - 类C代码：

    - ```c
      //不完善
      int Search_Bin(SSTable ST, KeyType key, int low, int high)
      {
          if(low > high)
              return 0;
          mid = (low + high) / 2;
          if(key == ST.R[mid].key)
              return key;
          if(key < ST.R[mid].key)
          {
              high = mid - 1;
              Search_Bin(ST, key, low, high);
          }
          else
          {
              low = mid + 1;
              Search_Bin(ST, key, low, high); 
          }
      }
      ```

  - C语言实现：

    - ```c
      ```

- 折半查找算法分析：

  - 判定树
  - 比较次数 = 路径上的结点数 = 结点的层数、
  - 比较次数 <= 树的深度 = logn + 1，向下取整

- 折半查找特点：

  - 优点：效率比顺序查找高
  - 缺点：只适用与有序表，且限于顺序存储结构（对线性链表无效）

### 3.分块查找

- 条件：
  - 将表分成几块，且表有序、或分块有序，若i < j，则第 j 块中所有记录的关键字均大于第 i 块中最大的关键字
  - 建立索引表（每个结点含有最大关键字和指向本块第一个结点的指针，且按关键字有序
- 查找过程：
  - 先确定待查记录所在块（顺序查找），然后再在块内查找（顺序查找）
- 分块查找算法分析及比较
- 分块查找特点：
  - 优点：插入和删除比较容易，无需进行大量移动
  - 缺点：要增加一个索引表的储存空间并对初始索引表进行排序算法
  - 适用情况：如果线性表既要快速查找又经常动态变化，则可采用分块查找
- 分块查找的算法分析

### 4.查找方式比较

|          |     顺序查找     | 折半查找 |     分块查找     |
| -------- | :--------------: | :------: | :--------------: |
| ASL      |       最大       |   最小   |       中间       |
| 表结构   |  有序表、无序表  |  有序表  |     分块有序     |
| 存储结构 | 顺序表、线性链表 |  顺序表  | 顺序表，线性链表 |

## （三）树表的查找

- 当表中插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录，改用动态查找表 --- 几种特殊树，表结构在查找过程中动态产生，对于指定key，若表中存在，则成功返回；否则，插入关键字d等于key的记录

  - 二叉排序树

  - 平衡二叉树

  - 红黑树

  - B-树

  - B+树

  - 键树

### 1.二叉排序树

  - 又称二叉搜索树、二叉查找树

  - 定义：

    - 二叉排序树或是空树，或是满足以下性质的二叉树
      - 若其左子树非空，则左子树上所有结点的值均**小于**根结点的值
      - 若其右子树非空，则右子树上所有结点的值均**大于等于**根结点的值
      - 其左右子树本身又各是一棵二叉排序树

  - 二叉排序树性质：

    - **中序遍历**非空的二叉排序树所得到的数据元素序列是一个按照关键字排序的递增有序序列
#### 二叉排序树的操作 --- 查找

- 二叉排序树的查找：

  - 若查找的关键字等于根结点，成功
  - 否则
    - 若小于根结点，查其左子树
    - 若大于根结点，查其右子树

  - 在左右子树上的操作类似

- 二叉排序树的存储结构

  - ```c
    typedef struct
    {
        KeyType key;//关键字项
        ...
        InfoType otherinfo;//其他数据域
    }ElemType;
    typedef struct
    {
        ElemType data;//数据域
        struct BSTNode *lchild, *rchild;//左右孩子指针
    }BSTNode, *BSTree;
    BSTree T;//定义二叉排序树
    ```

- 算法：二叉排序树的递归查找

  - 算法思想：

    - 若二叉排序树为空，则查找失败，返回空指针
    - 若二叉排序树非空，将给定值key与根结点的关键字`T->data.key`进行比较：
      - 若`key == T->data.key`，则查找成功，返回根结点地址
      - 若`key < T->data.key`，则进一步查找左子树
      - 若`key > T->data.key`，则进一步查找右子树

  - 类C代码：

    - ```c
      BSTree SearchBST(BSTree T, KeyType key)
      {
          if(!T || key == T->data.key)
              return T;
          if(key < T->data.key)
              return SearchBST(T->lchild,key);
          return SearchBST(T->rchild,key);
      }
      ```

- 二叉排序树查找算法分析：

  - 比较的关键字次数 = 此结点所在层数 = 最多比较次数 = 树的深度
  - 含有 n 个结点的二叉排序树的平均查找长度和**树的形态*有关
  - 最好情况，与折半查找相同
  - 最坏情况，与顺序查找相同
  - 问题：如何提高形态不均衡的二叉排序树的查找效率？
    - 做平衡化处理，尽量让二叉树的形状均衡


#### 二叉排序树的操作 --- 插入

- 二叉排序树的插入：
  - 若二叉排序树为空，则插入结点作为根结点插入到空树中
  - 否则，继续在其左右子树上查找
    - 树中已有，不再插入
    - 树中没有
      - 查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子


#### 二叉排序树的操作 --- 生成

- 二叉排序树的生成：
  - 从空树出发，经过一系列的查找、插入操作之后，可生成一棵二叉排序树
  - 构造树的过程就是对无序序列排序的过程
  - 不同插入次序生成不同形态的二叉排序树

#### 二叉排序树的操作 --- 删除

- 从二叉排序树中删除一个结点，不能把以该结点为根的子树都删去，只能删掉该结点，并且还应保证删除后的二叉树仍然满足二叉排序树的性质不变。由于中序遍历二叉排序树可以得到一个递增有序的序列，那么，在二叉排序树中删去一个结点相当于删去有序序列中的一个结点
  - 将因删除结点而断开的二叉链表重新链接起来
  - 防止重新链接后树的高度增加
- 二叉排序树的删除
  - 若被删除的结点是叶子结点：直接删去该结点
  - 若被删除的结点只有左子树或只有右子树，用其左子树或右子树替换它
    - 其双亲结点的相应指针域的值改为：指向被删除结点的左子树或右子树
  - 若被删除的结点既有左子树，又有右子树
    - 以其中序前驱值替换之，然后删除该前驱结点，前驱是**左子树中最大的结点**
    - 也可以用其后继替换之，然后删除该后继结点，后继是**右子树中最小结点**

### 2.平衡二叉树

#### 平衡二叉树的定义：

- 平衡二叉树（balanced binary tree)，又称AVL树（Adelson - Velskii and Landis）
- 一棵平衡二叉树或是空树，或是具有以下性质的二叉排序树
  - 左子树与右子树的高度差的绝对值小于等于1
  - 左子树和右子树也是平衡二叉排序树

- 为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）
  - 平衡因子 = 结点左子树的高度 - 结点右子树的高度差

  - 根据平衡二叉树的定义，平衡二叉树上所有结点的平衡因子只能是-1 、 0 、1

#### 失衡二叉树的分析与调整

  - 当我们在平衡二叉排序树上插入一个结点时，有可能导致失衡，即出现平衡因子绝对值大于1的结点，如：2 、 -2。如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡
  - A：失衡结点：不止一个失衡结点时，为最小失衡子树的结点
  - B：A结点的孩子，C结点的双亲
  - C：插入新结点的子树
  - 平衡调整的四种类型：
    - LL型：
      - 调整过程：
        - B结点带着左子树一起上升
        - A结点成为B的右孩子（A比B大）
        - 原来B结点的右子树作为A的左子树（B的右子树比B大，比A小）
    - RR型：
      - 调整过程：
        - B结点带着右子树一起上升
        - A结点成为B的左孩子（A比B小）
        - 原来B结点的左子树作为A的右子树（B的左子树比B小，比A大）
    - LR型：
      - 调整过程：
        - C结点穿过A、B结点上升
        - B结点成为C的左孩子（B比C小）
        - A结点成为C的右孩子（A比B大）
        - 原来C结点的左子树作为B的右子树（C的左子树比B大）
        - 原来C结点的右子树作为A的左子树（C的右子树比A小）
    - RL型：
      - 调整过程：
        - C结点穿过A、B结点上升
        - A结点成为C的左孩子（A比C小）
        - B结点成为C的右孩子（B比C大）
        - 原来C结点的左子树作为A的右子树（C的左子树比A大）
        - 原来C结点的右子树作为B的左子树（C的右子树比B小）
  - 调整原则：
    - 降低高度
    - 保持二叉排序树的性质

## （四）哈希表（散列表）的查找

### 1.散列表的基本概念：

#### 基本思想：

- 记录的存储位置与关键字之间存在对应关系（对应关系 --- hash函数）
  - `Loc( i ) = H( keyi )`，hash函数；Hash哈希：翻译为：散列、杂凑

#### 如何查找：

- 根据散列函数`H(key) = k`
  - 查找`key = 9`，则访问`H(9) = 9`号地址，若内容为9则成功
  - 若查不到，则返回一个特殊值，如空指针或空记录
- 优点：查找效率高
- 缺点：空间效率低

#### 散列表的若干术语

- 散列方法（杂凑法）：
  - 选取某个函数，依该函数按关键字计算元素的储存位置，并按此存放；
  - 查找时，由同一个函数对给定值 k 计算地址，将 k 与地址单元中元素关键码进行对比，确定查找是否成功
- 散列函数（杂凑函数）：
  - 散列方法中使用的转换函数
  - `H(key) = k`
- 散列表（杂凑表）：
  - 按上述思想构造的表
- 冲突：
  - 不同的关键码映射到同一个散列地址
  - key1 != key2，但是H(key1) = H(key2)
- 同义词：
  - 具有相同函数值的多个关键字

### 2.散列函数的构造

- 在散列查找方法中，冲突是不可避免的，只能尽可能减少

- 使用散列表要解决好两个问题：
  1. 构造好的散列函数
     - 所选函数尽可能简单 ，以便提高转换速度
     - 所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费
  2. 制定一个好的解决冲突的方案
     - 查找时，如果从散列函数计算出的地址中查不到关键码，则应当依照解决冲突的规则，有规律地查询其他相关单元
  
#### 构造散列函数考虑的因素：
  - 执行速度（即计算散列函数所需的时间）
  - 关键字的长度
  - 散列表的长度
  - 关键字的分布情况
  - 查找频率

#### 根据元素集合的特性构造
  - 要求1：n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的地址空间尽量小
  - 要求2：无论用什么方法储存，目的都是尽量均匀地存放元素，以避免冲突
    - 直接定址法
      - `Hash(key) = a * key + b` `(a、b为常数)`
      - 优点：以关键码key的某个线性函数值为散列地址，不会产生冲突
      - 缺点：要占用连续地址空间，空间效率低
    - 数字分析法
    - 平方取中法
    - 折叠法
    - 除留余数法
      - `Hash(key) = key mod p` `(p是一个整数)`
      - 关键：如何选取合适的p?
      - 技巧：设表长为 m，取 p <= m 且为质数
      - 例：15，23，27，38，53，61，70
        - `Hash(key) = key mod 7`
    - 随机数法

#### 解决冲突的方法：
##### a.开放定址法（开地址法）

- 基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入
- 例如：除留余数法 `Hi = (Hash(key) +di) mod m` `(p是一个整数)` `di为增量序列`
- 常用方法：
  - 线性探测法：di 为 1、2、...、m-1 线性序列
    -  `Hi = (Hash(key) +di) mod m`  `(1 <= i < m)`
      - 其中：m为散列长度，di为增量序列1、2、...、m-1，且di = i
    - 一旦冲突，就找下一个地址，直到找到空地址存入
    -  例：关键码集为 {47，7，29，11，16，92，22，8，3}
       - 设：散列函数为 `Hash(key) = key mod 11`
         1. 47，7均是由散列函数得到的没有冲突的散列地址，`Hash(47) = 47 mod 11 = 3`，`Hash(7) = 7 mod 11 =7`
         2. `Hash(29) = 7`，散列地址有冲突，需要寻找下一个空的散列地址，由`H1 = (Hash(29) + 1) mod 11 =8` ，散列地址为8，将29存入
         3. 依次进行
  - 二次探测法：di 为 1^2、-1^2，2^2，-2^2，...，q^2 二次序列
    - 例：关键码集为 {47，7，29，11，16，92，22，8，3}
      - 设：散列函数为 `Hash(key) = key mod 11`
        - `Hi = (Hash(key) +di) mod m`
        - 其中 m 为散列表长度，m 要求是某个`4k + 3 `的质数；di为1^2、-1^2，2^2，-2^2，...，q^2 二次序列
      - Hash(3) = 3，散列地址冲突，由`H1 = (Hash(3) + 1^2) mod 11 = 4`，仍然冲突
      - `H2 = (Hash(3) - 1^2) mod 11 = 2`，找到空的散列地址，存入
  - 伪随机探测法：di 为伪随机数序列
    - `Hi = (Hash(key) +di) mod m`
      - 其中 m 为散列表长度
      - di为伪随机数

##### b.链地址法（拉链法）

- 基本思想：相同散列地址的记录链成一个单链表，m 个散列地址就设 m 个单链表，然后用一个数组将 m 个单链表的表头指针储存起来，形成一个动态的结构
- 链地址法建立散列表步骤：
  1. 取数据元素的关键字key，计算其散列表函数值（地址）。若该地址对应的链表为空，则该元素插入此链表；否则执行步骤2
  2. 根据选择的冲突处理方法，计算关键字 key 的下一个储存地址。若该地址对应的链表不为空，则利用链表的前插法或后插法将该元素插入此链表
- 链地址法的优点：
  - 非同义词不会冲突，无聚集现象
  - 链表上的结点空间动态申请，更适合于表长不确定的情况

##### c.再散列法（双散列函数法）

##### d.建立一个公共溢出区

### 3.散列表查找性能分析

- 使用平均查找长度ASL来衡量查找算法，ASL取决于：
  - 散列函数
  - 处理冲突的方法
  - 散列表的装填因子α（α = 表中填入的记录数 / 哈希表的长度）
    - α 越大，表中记录元素越多，说明表装的越满，发生冲突的可能性就越大，查找时比较次数就越多
    - ASL与装填因子 α 有关，既不是严格的O(1)，也不是O(n)
      - 拉链法：ASL ≈ 1 + α / 2
      - 线性探测法：ASL ≈ 1/2（1 + 1/（1 - α））
      - 随机探测法：ASL ≈ -1/α  * ln(1 - α )
- 几点结论：
  - 散列表技术具有很好的平均性能，对于一些传统的技术
  - 链地址法优于开地址法
  - 除留余数法作散列函数优于其他类型函数

# 八.排序

## （一）排序概述

### 1.排序：将一组杂乱无章的数据按一定规律顺次排列起来，即，将无序序列排成一个有序序列（由小到大或由大到小）的运算

- 如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言

### 2.排序方法分类：

- 按数据存储介质：内部排序和外部排序
  - 内部排序：数据量不大，数据再内存，无需内外存交换数据
  - 外部排序：数据量较大，数据在外存（文件排序）
    - 外部排序时，要将数据分批调入内存来排序，中间结果还要及时放回外存，显然外部排序要复杂得多
- 按比较器个数：串行排序和并行排序
  - 串行排序：单处理机（同一时刻比较一对元素）
  - 并行排序：多处理机（同一时刻比较多对元素）
- 按主要操作：比较排序和基数排序
  - 比较排序：用比较的方法
    - 插入排序、交换排序、选择排序、归并排序
  - 基数排序：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置
- 按辅助空间：原地排序和非原地排序
  - 原地排序：辅助空间为O(1)	
    - （所占辅助存储空间与参加排序的数据量大小无关
  - 非原地排序：辅助空间用量超过O(1)的排序方法
- 按稳定性：稳定排序和非稳定性排序
  - 稳定排序：能够使任何数值相等的元素，排序以后相对次序不变
    - 排序的稳定性只对结构类型数据排序有意义
    - 排序方式是否稳定，并不能衡量一个排序算法的优劣
  - 非稳定性排序：不是稳定排序的方法
- 按自然性：自然排序和非自然排序
  - 自然排序：输入数据越有序，排序的速度越快的排序方法
  - 非自然排序：不是自然排序的方法
- 按排序原则：
  - 插入排序：直接插入排序、折半插入排序、希尔排序
  - 交换排序：冒泡排序、快速排序
  - 选择排序：简单选择排序、堆排序
  - 归并排序：2-路归并排序
  - 基数排序
- 按排序所需工作量：
  - 简单的排序方法：T(n) = O(n^2)
  - 基数排序：T(n) = O(d.n)
  - 先进的排序方法：T(n) = O(nlogn)

- 存储结构（记录序列以顺序表存储）

  - ```c
    #define MAXSIZE 20 //设记录不超过20个
    typedef int KeyType; //设关键字为整型
    typedef struct //定义每个记录（数据元素）的结构
    {
        KeyType key; //关键字
        ...
        InfoType otherinfo; //其他数据项
    }RedType;
    typedef struct //定义顺序表的结构
    {
        RedType r[MAXSIZE + 1]; //存储顺序表的向量 //r[0]一般作哨兵或缓冲区
        int length; //顺序表的长度
    }SqList;
    ```

## （二）插入排序

### 1.基本思想：

- 每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止
- 即边插入边排序，保证子序列中随时都是排好序的

### 2.基本操作：

- 有序插入
  - 在有序序列中插入一个元素，保持序列有序，有序长度不断增加
  - 起初`a[0]`是长度为1的子序列，然后，逐一将`a[1]`至`a[n-1]`插入到有序子序列中
    - 在插入`a[i]`前，数组a的前半段`(a[0]~a[i-1])`是有序段，后半段`(a[i]~a[n-1])`是停留于输入次序的无序段
    - 插入a[i]使`a[0]~a[i]`有序，也就是要为`a[i]`找到有序位置` j (0<=j<=i)`，将`a[i]`插入在`a[j]`的位置上

### 3.插入排序的种类：

#### （1）直接插入排序：

- 顺序法定位插入位置

  - 不使用哨兵：
    - 复制插入元素`x = a[i];`
    
    - 记录后移，查找插入位置 
    
      - ```c 
        for(j = i - 1; j >= 0 && x < a[j] ;j--) 
            a[j+1] = a[j];
        ```
    
    - 插入到正确位置`a[j+1] = x;`
    
  - 使用哨兵：
    - 复制插入元素` L.r[0]= L.r[i];`
    
    - 记录后移，查找插入位置 
    
      - ```c
        for(j = i - 1; L.r[0].key < L.r[j].key ;j--)	//每一轮都可以少比较一次
            L.r[j+1] = L.r[j];
        ```
    
    - 插入到正确位置`L.r[j+1] = L.r[0];`

- 类C代码：

  - ```c
    void InserSort(SqList &L)
    {
        int i , j;
        for(i = 2; i <= L.length; i++)	//从第二个元素开始插入到有序序列
        {
            if(L.r[i].key < L.r[i-1].key)	//判断新插入的元素是否比已排序的最后一个元素大，如果大则不需要移动元素
            {
                L.r[0] = L.r[i];//复制为哨兵
                for(j = i - 1; L.r[0].key < L.r[j].key ;j--) 
                {
                    L.r[j+1] = L.r[j];	
                }    //循环结束时代表第j位元素小于新插入元素，j+1位为要插入的位置  
                L.r[j+1] = L.r[0]; //插入到正确位置
            }  
        }
    }
    ```
  
- C语言实现：

  - ```c
    //直接插入排序（使用哨兵）
    void InserSort(SqList* L)
    {
    	int i, j;
    	int a = 0;	//比较次数
    	int b = 0;	//移动次数
    	for (i = 2; i <= L->length; i++)	//从第二个元素开始插入到有序序列
    	{
    		if (++a && L->r[i].key < L->r[i - 1].key)	//判断新插入的元素是否比已排序的最后一个元素大，如果大则不需要移动元素
    		{
    			L->r[0] = L->r[i];//复制为哨兵
    			for (j = i - 1;++a && L->r[0].key < L->r[j].key; j--)	//从已排好序的序列的最后一个从后往前比较，如果大于哨兵，则后移
    			{
    				L->r[j + 1] = L->r[j];
    				b++;
    			}	//循环结束时代表第j位元素小于新插入元素，j+1位为要插入的位置
    			L->r[j + 1] = L->r[0]; //插入到正确位置
    			b++;
    		}		
    	}
    	printf("直接插入排序比较次数为：%d\n", a);
    	printf("直接插入排序移动次数为：%d\n", b);
    }
    
    ```

- 直接插入排序性能分析：

  - 实现排序的基本操作有两个：
    1. 比较序列中两个关键字的大小
    2. 移动记录
  - 最好情况（已经有序）：
    - 比较次数：n-1
    - 移动次数：0
  - 最坏情况（逆序有序）：
    - 比较次数：(n+2)(n-1)/2	（第二个元素开始，需要比较两次，第 n 个元素需要比较 n 次，后面一共 n-1 个元素）
    - 移动次数：(n+4)(n-1)/2
  - 时间复杂度结论：
    - 原始数据越接近有序，排序速度越快
    - 最坏情况下：O(n^2)
    - 平均情况：大约是最坏情况下的一半，O(n^2)

#### （2）二分插入排序：

- 二分法定位插入位置

- 类C代码：

  - ```c
    void BInsertSort(SqList &L)
    {
        for(i = 2; i <= L.length; i++) //依次插入第2~n个元素
        {
            L.r[0] = L.r[i]; //当前插入元素存到哨兵位置
            //已排好序的部分为1~i-1
            low = 1;
            high = i-1; //采用二分法查找插入位置
            while(low <= high)
            {
                mid = (low + high) / 2;
                if(L.r[0].key < L.r[mid].key)
                {
                     high = mid -1;
                }
                else
                {
                    low = mid +1;
                } 
            }	//循环结束，high + 1则为插入位置
            for(j = i - 1; j >=high + 1; j--)
                    L.r[j+1] = L.r[j]; //移动元素
            L.r[high+1] = L.r[0];	//插入到正确位置
        }
    }
    ```

- C语言实现：

  - ```c
    ```

- 折半插入排序算法分析：

  - 折半查找比顺序查找快，所以折半查找排序就平均性能来说比直接插入排序要快
  - 它所需要的关键码比较次数与待排序对象序列的初始无关，仅依赖与对象个数。在插入第 i 个对象时，需经过`logi + 1`次关键码比较，才能确定它应插入的位置
    - 当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差
    - 在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半查找执行的关键码比较次数要少
  - 折半查找排序的对象移动次数与直接插入排序相同，依赖与对象的初始排列
    - 减少了比较次数，但没有减少移动次数
    - 平均性能优于直接排序
      - 时间复杂度O(n^2)
      - 空间复杂度O(1)
      - 是一种稳定的排序方法

#### （3）希尔排序：

- 特点：

  - 缩小增量
  - 多遍插入排序

- 思考：直接插入排序在基本有序时，效率比较高；在待排序记录个数较少时，效率较高

- 基本思想：

  - 先将整个待排记录序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录基本有序时，再对整个全体记录进行一次直接插入排序

- 希尔排序思路：

  - 定义增量序列（依次递减，最后是为1的序列）
  - 对每个Dk进行间隔插入排序

- 希尔排序特点：

  - 一次移动，移动位置较大，跳跃式地接近排序后的最终位置
  - 最后一个只需要少量移动
  - 增量移动必须时递减的，最后一个必须是1
  - 增量序列应该是互质的

- 希尔排序算法（主程序）

  - 类C代码：

    - ```c
      void ShellSort(SqList &L, int dlta[], int t)
      {
          //按增量序列dlta[0...t-1]对顺序表L作希尔排序
          for(k = 0; k < t; ++k)
              ShellInsert(L, dlta[k]); //一趟增量为dlta[k]的插入排序
      }
      ```

  - C语言实现：

    - ```c
      ```

- 希尔排序算法（其中某一趟的排序操作）

  - 类C代码：

    - ```c
      //???
      void ShellInsert(SqList &L, int dk)
      {
          //对顺序表L进行一趟增量为dk的Shell排序，dk为步长因子
          //从第一组的第二个开始，第二次是第二组的第二个，并不是一组一组的进行，而是所有组的第i个一起进行
          for(i = dk + 1; i <= L.length; i++)	
          {
              if(r[i].key < r[i-dk].key)
              {
                  r[0] = r[i];	//每次进来都重置哨兵，并与自己所在组的元素比较
                  for(j = i - dk; j > 0 && (r[0].key < r[j].key); j = j - dk)
                      r[j+dk] = r[j];
                  r[j+dk] = r[0];
              }
          }
      }
      ```

  - C语言实现：

    - ```c
      
      ```

- 希尔排序算法分析：

  - 希尔排序算法效率与增量序列的取值有关
  - Hibbard增量序列
    - Dk = 2^(k-1)  ---  相邻元素互质
    - 最坏情况：T = O(n^(3/2))
    - 猜想：Tavg = O(n^(5/4))
  - Sedgewicl增量序列
    - ...
    - 最坏情况：T = O(n^(4/3))
    - 猜想：Tavg = O(n^(7/6))
  - 希尔排序是一种不稳定的排序算法
  - 如何选择最佳d序列，目前尚未完全解决
  - 最后一个增量值必须为1，无除了1之外的公因子
  - 不宜再链式存储结构上实现

## （三）交换排序

- 基本思想：

  - 两两比较，如果发生逆序则交换，直到所有记录都排好序位置

- 常见的交换排序算法：

  - 冒泡排序：O(n^2)

  - 快速排序：O(nlogn)

### 1.冒泡排序：

  - 总结：

    - n个记录，总共需要n-1趟

    - 第m趟需要比较n-m趟

  - 冒泡排序算法：

    - 类C代码：

      - ```c
        void bubble_sort(SqList &L)
        {
            int m, i, j;
            RedType x; //交换时用于临时储存
            for(m = 1; m <= n-1; m++)
            {
                for(j = 1; j<= n-m; j++)
                {
                    if(L.r[j].key >L.r[j+1].key) //发生逆序
                    {
                        x = L.r[j];
                        L.r[j] = L.r[j+1];
                        L.r[j+1] = x;
                    }
                }
            }
        }
        ```

    - C语言实现：

      - ```c
        void bubble_sort(SqList* L)
        {
        	int i, j;
        	int a = 0;	//比较次数
        	int b = 0;	//交换次数
        	RedType x; //交换时用于临时储存
        	for (i = 1; i <= L->length -1; i++)	//n个元素需要n-1趟冒泡排序
        	{
        		for (j = 1; j <= L->length - i; j++)	//每一趟需要比较的元素减少一个
        		{
        			if (++a && L->r[j].key >L->r[j + 1].key) //发生逆序，则交换
        			{
        				x = L->r[j];
        				L->r[j] = L->r[j + 1];
        				L->r[j + 1] = x;
        				b++;
        			}
        		}
        	}
        	printf("冒泡排序比较次数为：%d\n", a);
        	printf("冒泡排序交换次数为：%d\n", b);
        }
        ```

  - 优点：每趟排序时，不仅能挤出一个最大值到最后面，还能同时部分理顺其他元素

  - 思考：如何提高效率？

    - 一旦某一趟比较时不出现记录交换，说明已经排好序了，就可以直接结束本算法

  - 改进的冒泡排序算法：

    - 类C代码：

      - ```c
        void bubble_sort(SqList &L)
        {
            int m, i, j;
            int flag = 1; //flag用于标记是否发生了交换
            RedType x; //交换时用于临时储存
            for(m = 1; m <= n-1 && flag == 1; m++)
            {
                flag = 0;
                for(j = 1; j<= n-m; j++)
                {
                    if(L.r[j].key >L.r[j+1].key) //发生逆序
                    {
                        flag = 1; //若发生了交换，则将flag置于1，下一趟排序算法继续；若本趟未交换，则结束排序
                        x = L.r[j];
                        L.r[j] = L.r[j+1];
                        L.r[j+1] = x;
                    }
                }
            }
        }
        ```
      
    - C语言实现：
    
  - ```c
      ```

  - 冒泡排序算法分析：

    - 最好情况：时间复杂度O(n)
    - 最坏情况：时间复杂度O(n^2)
    - 平均时间复杂度O(n^2)
    - 辅助空间S(n) = O(1)
    - 冒泡排序是稳定的

### 2.快速排序

- 改进的交换排序

#### （1）基本思想：

  - 任取一个元素为中心（pivot：枢轴、中心点）
    - 枢轴、中间数：可以是第一个数、最后一个数、最中间一个数、任选一个数
  - 所有比他小的元素一律前放，比他大的元素一律后放，形成两个左右子表
  - 对各子表重新选择中心元素并依此规则调整（递归）
  - 直到每一个子表的元素只剩一个
  - 总结：通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分进行排序，以达到整个序列有序

#### （2）具体实现：

  - 选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边

#### （3）步骤：

  - 每一趟子表的形成是采用从两头向中间交替式逼近法
  - 由于每趟中对各子表的操作都相似，可采用递归算法

#### （4）快速排序算法：

  - 类C代码：

    - ```c
      void main()
      {
          QSort(L, 1, L.length);	//第二个参数为中心点位置，第三个参数为所选部分的最后一个元素位置
      }
      void QSort(SqList &L, int low, int high) //对顺序表L快速排序（递归）
      {
          if(low < high) //长度大于1
          {
              //找中心点元素位置
              pivotloc = Partition(L, low, high); //将L.r[low...high]一分为二，pivotloc为枢轴元素排好序的位置
              QSort(L, low, pivotloc-1); 	//对低子表递归排序
              QSort(L, pivotloc+1, high); //对高子表递归排序
          }
      }
      int Partition(SqList &L, int low, int high)
      {
          L.r[0] = L.r[low];
          pivotkey = L.r[low].key;
          while(low < high)
          {
              while(low < high && L.r[high].key >= pivotkey)
                  high--;
              L.r[low] = L.r[high];
              while(low < high && L.r[low].key <= pivotkey)
                  low++;
              L.r[high] = L.r[low];
          }	//结束时，low和high都指向中心点元素应该在的位置
          L.r[low] = L.r[0];
          return low;	//返回中心点位置
      }
      ```

  - C语言实现：
  
    - ```c
      //对顺序表L快速排序（递归）
      void QSort(SqList* L, int low, int high) 
      {
      	if (low < high) //长度大于1时才需要继续进行快速排序，否则认为已经有序，递归结束
      	{
      		//找中心点元素位置
      		int pivotloc;
      		pivotloc = Partition(L, low, high); //将L.r[low...high]一分为二，pivotloc为枢轴元素排好序的位置
      		QSort(L, low, pivotloc - 1); 	//对低子表递归排序
      		QSort(L, pivotloc + 1, high); //对高子表递归排序
      	}
      }
      
      //将比中心点大的元素放在一边，比中心点小的元素放在另一边，并且返回中心点的位置，方便进一步分别排序
      int Partition(SqList* L, int low, int high)
      {
      	KeyType pivotkey;
      	L->r[0] = L->r[low];	//将中心点元素存在哨兵位置，相当于原哨兵位置变得可以使用
      	pivotkey = L->r[low].key;
      	while (low < high)
      	{
      		//如果最后位置的元素大于等于哨兵，则指针前移，直到找到比哨兵小的元素
              while (low < high && L->r[high].key >= pivotkey)	
      			high--;
              //将小于哨兵的元素放在最前面，此时这个位置相当于空出来，可以使用
      		L->r[low] = L->r[high];
              //如果最前面位置的元素小于等于哨兵，则指针后移，直到找到比哨兵大的元素
      		while (low < high && L->r[low].key <= pivotkey)
      			low++;
              //将大于哨兵的元素放在最后面空出来的位置上
      		L->r[high] = L->r[low];
      	}	//结束时，low和high都指向中心点元素应该在的位置
          //将哨兵放在他应该在的位置上
      	L->r[low] = L->r[0];
      	return low;	//返回中心点位置
      }
      ```

#### （5）快速排序算法分析：

  - 时间复杂度

    - 平均计算时间O(nlogn)
      - Qsort：O(logn)
      - Partiton：O(n)

    - 就平均时间而言：快速排序是我们所讨论的所有排序方法中最好的一个

  - 空间复杂度：
    - 快速排序不是原地排序，由于程序中使用了递归，需要递归调用栈的支持，而栈的长度取决于递归调用的深度
      - 在平均情况下：需要O(logn)的栈空间
      - 最坏情况下：栈空间可达O(n)

  - 稳定性：快速排序是一种不稳定的排序方法
  - 快速排序不适用于原本有序或基本有序的记录序列进行排序
  - 划分元素的选取是影响时间的关键
  - 输入数据次序越乱，所划分元素值的随机性越好，排序速度越快，快速排序不是自然排序方法
  - 0改变划分元素的选取方法，至多只能改变算法平均情况下的时间性能，无法改变最坏情况下的时间性能。即最坏情况下，快速排序的时间复杂度总是O(n^2)


## （四）选择排序

### 1.简单选择排序

- 基本思想：

  - 在待排序的数据中选出最大（小）的元素放在最终位置

- 基本操作：

  - 首先通过 n-1 次关键字比较，从 n 个记录中找出关键字最小的记录，将他与第一个记录交换
  - 再通过 n-2 次比较，从剩余 n-1 个记录中找出关键字次小的记录，将它与第二个元素交换
  - 重复上述操作，共进行 n-1 趟排序后，排序结束

- 简单排序算法：

  - 类C代码：

    - ```c
      void SelectSort(SqList &K)
      {
          for(i = 1; i < L.length; i++)
          {
              k = i;	//开始时默认每趟的第一个为最小
              for(j = i + 1; j <= L.length; j++)
              {
                  if(L.r[j].key < L.r[k].key)
                      k = j; //记录最小值位置
              }
              if(k != i)
                      //交换L.r[i]与L.r[k]
          }
      }
      ```

  - C语言实现：

    - ```c
      //简单选择排序
      void SelectSort(SqList* L)
      {
      	int i, k, j;
      	RedType x; //交换时用于临时储存
      	int a = 0;	//比较次数
      	int b = 0;	//交换次数
      	for (i = 1; i <= L->length - 1; i++)
      	{
      		k = i;	//开始时默认每趟的第一个为最小
      		for (j = i + 1; j <= L->length; j++)	//从默认位置之后的元素开始寻找最小的元素
      		{
      			if (++a && L->r[j].key < L->r[k].key)
      			{
      				k = j; //记录最小值位置
      			}				
      		}
      		//一趟执行完以后，交换L.r[i]与L.r[k]
      		if (k != i)	//如果最小的位置不是默认位置，则需要交换
      		{
      			x = L->r[i];
      			L->r[i] = L->r[k];
      			L->r[k] = x;
      			b++;
      		}
      	}
      	printf("简单选择排序比较次数为：%d\n", a);
      	printf("简单选择排序交换次数为：%d\n", b);
      	printf("简单选择排序移动次数为：%d\n",3*b);
      }
      ```

- 简单选择排序算法分析：

  - 时间复杂度：
    - 记录移动次数：
      - 最坏情况：0
      - 最坏情况：3（n-1）
        - 交换次数为：n-1
    - 比较次数：无论待排序列处于什么状态，选择排序所需比较的次数都相同
      - n(n-1)/2			n-1到1，共n-1趟
  - 稳定性：简单选择排序是不稳定排序
    - 例：8 5 7 7 9

### 2.堆排序

#### （1）堆的定义：

- 若 n 个元素的序列{a1 a2 ... an}满足
  - ai <= a2i
  - ai <= a(2i+1)
    - 或
  - ai >= a2i
  - ai >= a(2i+1)
- 则分别称该序列为 小根堆 和 大根堆

- 从堆的定义可以看出：

  - 堆实质是满足以下性质的完全二叉树：
    - 二叉树中任一非叶子结点均小于（大于）它的孩子结点000

- 堆排序：

  - 若在输出堆顶的最小值（最大值）后，使得剩余 n-1 个元素的序列重新建成一个堆，则得到 n 个元素的次小值（次大值）...如此反复，便能得到一个有序序列，这个过程称为 堆排序

#### （2）实现堆排序需要解决两个问题：

##### 问题1：如何由一个无序序列建成一个堆？

- 显然：

  - 单结点的二叉树是堆；在完全二叉树中所有叶子结点（序号 i > n/2）为根的子树是堆。这样我们只需要依次将以序号 n/2，n/2-1，...，1 的结点为根子树均调整为堆即可

- 从最后一个非叶子结点开始，依次向前调整：

  - 调整从第 n/2 个元素开始，将以该元素为根的二叉树调整为堆
  - 将以序号为 n/2-1 的结点为根的二叉树调整为堆
  - 将以序号为 n/2-2 的结点为根的二叉树调整为堆
  - 将以序号为 n/2-3 的结点为根的二叉树调整为堆

- 将初始无序的 R[1] 到 R[n] 建成一个小根堆，可用以下语句实现：

  - ```c
    for(i = n/2; i >= 1; i--)
    {
        HeapAdjust(R, i, n);
    }    
    ```

- 由以上分析可知：

  - 若对一个无序序列建堆，然后输出根；重复该过程就可以由一个无序序列输出有序序列
  - 实质上，堆排序就是利用完全二叉树中父结点与孩子结点之间的内在关系来排序的

- 堆排序算法：

  - 类C代码：

    - ```c
      void HeapSort(elem R[]) //对R[1]到R[n]进行堆排序
      {
          int i;
          for(i = n/2; i >= 1; i--)	//i = n/2 找到最后一个非叶子结点
          {
              HeapAdjust(R, i, n); //建初始堆
          }
          for(i = n; i > 1; i--) //进行n-1趟排序
          {
              Swap(R[1], R[i]); //根与最后一个元素交换
              HeapAdjust(R, 1, i-1); //对R[1]到R[i-1]重新建堆
          }
      }
      ```
    
  - C 语言实现：
  
    - ```c
      //堆排序
      void HeapSort(SqList* L) 
      {
      	int i, n;
      	RedType tmp;
      	n = L->length;
      
      	for (i = n / 2; i >= 1; i--)	//i = n/2 找到最后一个非叶子结点
      	{
      		HeapAdjust(L, i, n); //建初始堆
      	}
      	for (i = n; i > 1; i--) //进行n-1趟排序
      	{
      		//根与最后一个元素交换
      		tmp = L->r[1];
      		L->r[1] = L->r[i];
      		L->r[i] = tmp;
      		h_b += 3;
      		HeapAdjust(L, 1, i - 1); //对R[1]到R[i-1]重新建堆
      	}
      }
      ```
  
    - 

##### 问题2：如何在输出堆顶元素后，调整剩余元素为一个新的堆？

- 小根堆：

  - 输出堆顶元素后，以堆中最后一个元素（从上到下从左到右编号，最后一个）代之

  - 然后将根结点值与左右子树的根结点值进行比较，并与其中小者交换

  - 重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为**筛选**

    - 小根堆筛选算法：

      - 类C代码：

        - ```c
          void HeapAdjust(elem R[], int s, int m)	//s为堆顶所在位置，m为最后一个元素所在位置
          {
              rc = R[s];	//保存堆顶元素
              for(j = 2*s; j <= m; j *= 2) //沿key较大的孩子向下筛选,j刚开始为堆顶结点的孩子结点，下一次为孩子结点的孩子结点（利用的是完全二叉树的性质）
              {
                  if(j < m && R[j] > R[j+1])
                  {
                       j++; //j为key较小的记录的下标（右结点更大）
                  }        
                  if(rc <= R[j])	//如果堆顶元素小于孩子结点中更小的一个，则直接跳出循环，该树已建成堆
                      break;
                  R[s] = R[j];	//将较小的的结点放在堆顶
                  s = j; //将原堆顶元素的位置改为原较小孩子的位置上，s下移一层
                  //一趟循环可将临时放在堆顶的元素向其应该在的位置移动一格
                  //循环结束，可将临时放在堆顶的元素这个元素移动到其应该在的位置
                  //循环结束即可将以原堆顶结点为根结点的树调整为堆
              }
              R[s] = rc; //将原堆顶元素放在原较小孩子的位置上
          }
          ```
    
      - C语言实现：
    
        - ```c
          //堆调整（小根堆）
          void HeapAdjust(SqList* L, int s, int m)	//s为堆顶所在位置，m为最后一个元素所在位置
          {
          	int j;
          	RedType rc = L->r[s];	//保存堆顶元素
          	for (j = 2 * s; j <= m; j *= 2) //沿key较小的孩子向下筛选
          	{
          		if (j < m && (L->r[j].key > L->r[j + 1].key))
          		{
          			j++; //j为key较小的记录的下标
          		}
          		if (rc.key <= L->r[j].key)	
          			break;
          		L->r[s] = L->r[j];
          		s = j; //rc应插入在位置s上
          	}
          	L->r[s] = rc; //插入
          }
          ```
    
      
    
    - 大根堆筛选过程的算法：
    
      - 类C代码：
    
        - ```c
          void HeapAdjust(elem R[], int s, int m)	//s为堆顶所在位置，m为最后一个元素所在位置
          {
              rc = R[s];	//保存堆顶元素
              for(j = 2*s; j <= m; j *= 2) //沿key较大的孩子向下筛选,j刚开始为堆顶结点的孩子结点，下一次为孩子结点的孩子结点（利用的是完全二叉树的性质）
              {
                  if(j < m && R[j] < R[j+1])
                  {
                       j++; //j为key较大的记录的下标（右结点更大）
                  }        
                  if(rc >= R[j])	//如果堆顶元素大于孩子结点中更大的一个，则直接跳出循环，该树已建成堆
                      break;
                  R[s] = R[j];	//将较大的的结点放在堆顶
                  s = j; //将原堆顶元素的位置改为原较大孩子的位置上，s下移一层
                  //一趟循环可将临时放在堆顶的元素向其应该在的位置移动一格
                  //循环结束，可将临时放在堆顶的元素这个元素移动到其应该在的位置
                  //循环结束即可将以原堆顶结点为根结点的树调整为堆
              }
              R[s] = rc; //将原堆顶元素放在原较大孩子的位置上
          }
          ```
    
      - C语言实现：
    
        - ```c
          //堆调整（大根堆）
          void HeapAdjust(SqList* L, int s, int m)	//s为堆顶所在位置，m为最后一个元素所在位置
          {
          	//建大根堆，将最大的元素放在最后面，即完成了从小到大排序
          	int j;
          	RedType rc = L->r[s];	//保存堆顶元素
          	for (j = 2 * s; j <= m; j *= 2) //沿key较大的孩子向下筛选
          	{
          		if (j < m && (L->r[j].key < L->r[j + 1].key))
          		{
          			j++; //j为key较大的记录的下标
          		}
          		if (rc.key >= L->r[j].key)	
          			break;
          		L->r[s] = L->r[j];
          		s = j; //rc应插入在位置s上
          	}
          	L->r[s] = rc; //插入
          }
          ```
    
    - 可以看出：对一个无序序列反复筛选就可以得到一个堆，即：从一个无序序列建堆的过程就是一个反复筛选的过程

#### （3）堆排序的算法性能分析：

- 初始堆化所需时间不超过O(n)
- 排序阶段（不含初始堆化）：
  - 一次重新堆化所需时间不超过O(logn)
  - n-1 次循环所需时间不超过O(nlogn)
    - Tw(n) = O(n) + O(nlogn) = O(nlogn)
- 堆排序的时间主要耗费在建初始堆和调整建新堆时进行的反复筛选上。堆排序在最坏情况下，其时间复杂度也为O(nlogn)，这是堆排序最大的优点。无论待排序列中的记录是正序还是逆序排列，都不会时堆排序处于最好或最坏状态
- 另外，堆排序仅需一个记录大小供交换用的辅助储存空间
- 然而堆排序是一种不稳定的排序方法，它不适用于待排序记录个数n较少的情况，但对于 n 较大的文件还是很有效的

## （五）归并排序

- b站up：请叫我AXin

- 基本思想：
  - 将两个或两个以上的有序子序列 归并 为一个有序序列
  
- 在内部排序中，通常采用的是 **2-路归并排序**
  - 即：将两个位置相邻的有序子序列归并
  - n个数据使用归并排序需要`logn`（向下取整）趟
  
- 如何将两个有序序列合成一个有序序列
  - 设 `R[low] - R[mid] `和` R[mid+1] - R[high] `为相邻，归并成一个有序序列 R1[low] - R1[high]
  - 若 `SR[ i ].key <= SR[ j ].key`，则` TR[ k ] = SR[ i ]; k++; i++`
    - 否则 `TR[ k ] = SR[ j ]; k++; j++`
  
- 归并排序算法分析：
  - 时间效率：O(nlogn)
  - 空间效率：O(n)
    - 因为需要一个于原始序列同样大小的辅助序列 R1。这正是此算法的缺点
  - 稳定性：稳定
  
- C语言实现：

  - ```c
    // 归并排序入口
    void merge_sort(SqList* L)
    {
    	RedType* a = (RedType*)malloc((MAXSIZE + 1)*sizeof(RedType));	//分配一个同样大小的辅助空间
    	if (a)	//辅助数组分配成功
    	{
    		msort(L, a, 1, L->length);
    		free(a);	//释放辅助空间
    	}
    	else
    	{
    		printf("error:分配失败！");
    	}
    }
    
    //归并排序
    void msort(SqList* L, RedType a[], int left, int right)	//原顺序表，辅助数组，左下标，右下标
    {
    	//如果只有一个元素，那么不需要继续划分
    	if (left < right)
    	{
    		int mid = (left + right) / 2;	//找中间点
    		msort(L, a, left, mid);	//递归继续划分，左半区
    		msort(L, a, mid + 1, right);	//右半区
    		merge(L, a, left, mid, right);	//当只有一个元素的时候开始合并
    	}
    }
    
    //合并
    void merge(SqList* L, RedType a[], int left, int mid, int right)
    {
    	//标记顺序表左半区第一个未排序的元素
    	int l_pos = left;
    	//标记顺序表左半区第一个未排序的元素
    	int r_pos = mid + 1;
    	//临时数组的下标
    	int pos = left;	//因为一个过程内需要合并的就是left到right这一部分
    	//合并
    	while (++m_a && l_pos <= mid && ++m_a && r_pos <= right)	//当左半区和右半区都还有元素时
    	{
    		if (++m_a && L->r[l_pos].key < L->r[r_pos].key)	//如果左半区第一个剩余元素小于右半区第一个元素
    		{
    			a[pos] = L->r[l_pos];	//将左半区元素放到辅助数组
    			pos++;
    			l_pos++;
    			++m_b;
    		}
    		else
    		{
    			a[pos] = L->r[r_pos];	//将右半区元素放到辅助数组
    			pos++;
    			r_pos++;
    			++m_b;
    		}
    	}
    	//合并左半区剩余的元素
    	while (++m_a && l_pos <= mid)
    	{
    		a[pos] = L->r[l_pos];	//将左半区元素放到辅助数组
    		pos++;
    		l_pos++;
    		++m_b;
    	}
    	//合并右半区剩余的元素
    	while (++m_a && r_pos <= right)
    	{
    		a[pos] = L->r[r_pos];	//将左半区元素放到辅助数组
    		pos++;
    		r_pos++;
    		++m_b;
    	}
    	//把临时数组中合并后的元素复制回原数组
    	while (left <= right)
    	{
    		L->r[left] = a[left];
    		left++;
    		++m_b;
    	}
    }
    ```


## （六）基数排序

- 基本思想：分配 + 收集
  - 也叫桶排序或箱排序：设置若干个箱子，将关键字为 k 的记录放入第 k 个箱子，如何在按序号将非空的连接
- 基数排序：
  - 数字是有范围的，均由0~9这十个数字组成，则只需设置十个箱子，相继按个、十、百进行排序
- 基数排序算法分析：
  - 时间效率：O(k*(n+m)) 
    - k：关键字个数
    - m：关键字取值范围为m个值
  - 空间效率：O(n+m)
  - 稳定性：稳定

## （七）外部排序

## 多种排序完整代码：

- ```c
  #define _CRT_SECURE_NO_WARNINGS
  #include<stdio.h>
  #include<stdlib.h>
  #include<time.h>
  
  #define MAXSIZE 10000	//线性表初始分配量
  #define OK 1	//成功标志
  #define  ERROR 0	//失败标志
  
  typedef int Status;	//Status 是函数的类型，其值是函数结果状态代码
  typedef int ElemType;	//ElemType的类型根据实际情况而定，这里假定为int
  typedef int KeyType; //设关键字为整型
  
  int q_a = 0;	//快速排序比较次数
  int q_b = 0;	//快速排序移动次数
  int h_a = 0;	//堆排序比较次数
  int h_b = 0;	//堆排序移动次数
  int m_a = 0;	//归并排序比较次数
  int m_b = 0;	//归并排序移动次数
  
  typedef struct //定义每个记录（数据元素）的结构
  {
  	KeyType key; //关键字
  }RedType;
  
  //顺序表数据结构
  typedef struct
  {
  	RedType r[MAXSIZE+1];
  	int length;
  }SqList;
  
  //函数声明
  Status InitList_Sq(SqList *L);	//顺序表的初始化
  Status S_ChangeList_Sq(SqList* L);
  Status N_ChangeList_Sq(SqList* L);
  void bubble_sort(SqList* L);	//冒泡排序
  void SelectSort(SqList* L);		//简单选择排序
  void InserSort(SqList* L);		//直接插入排序
  void QSort(SqList* L, int low, int high);//快速排序（递归）
  int Partition(SqList* L, int low, int high);
  void HeapSort(SqList* L);	//堆排序
  void HeapAdjust(SqList* L, int s, int m);	//堆调整
  void merge_sort(SqList* L);
  void merge(SqList* L, RedType a[], int left, int mid, int right);
  void msort(SqList* L, RedType a[], int left, int right);
  
  void print_Sq(SqList L);	//输出顺序表
  
  
  int main()
  {
  	SqList L;
  	clock_t start, finish; // 定义变量
  	double t;
  	FILE *fp1;
  	srand((unsigned int)time(NULL));//初始化随机数发生器
  
  	InitList_Sq(&L);
  
  	//写入文件
  	fp1 = fopen("data1.dat", "wb");
  	fwrite(L.r, sizeof(RedType), MAXSIZE+1, fp1);
  	fclose(fp1);
  	for (int i = 1; i <= MAXSIZE; i++)
  	{
  		L.r[i].key = 0;
  	}
  	//测试冒泡排序
  	fp1 = fopen("data1.dat", "rb");
  	fread(L.r, sizeof(RedType), MAXSIZE+1, fp1);
  	fclose(fp1);
  
  	start = clock();     //开始
  	//printf("冒泡排序前：\n");
  	//print_Sq(L);  //打印结果
  
  	bubble_sort(&L);
  	//printf("冒泡排序后：\n");
  	//print_Sq(L);  //打印结果
  
  	finish = clock();    //结束
  	t = (double)(finish - start);//计算运行时间
  	printf("time = %lfms\n\n", t);//输出运行时间
  
  	//测试简单选择排序
  	fp1 = fopen("data1.dat", "rb");
  	fread(L.r, sizeof(RedType), MAXSIZE + 1, fp1);
  	fclose(fp1);
  
  	start = clock();     //开始
  	//printf("简单选择排序前：\n");
  	//print_Sq(L);  //打印结果
  
  	SelectSort(&L);
  	//printf("简单选择排序后：\n");
  	//print_Sq(L);  //打印结果
  
  	finish = clock();    //结束
  	t = (double)(finish - start);//计算运行时间
  	printf("time = %lfms\n\n", t);//输出运行时间
  
  	//测试直接插入排序
  	fp1 = fopen("data1.dat", "rb");
  	fread(L.r, sizeof(RedType), MAXSIZE + 1, fp1);
  	fclose(fp1);
  
  	start = clock();     //开始
  	//printf("直接插入排序前：\n");
  	//print_Sq(L);  //打印结果
  
  	InserSort(&L);
  	//printf("直接插入排序后：\n");
  	//print_Sq(L);  //打印结果
  
  	finish = clock();    //结束
  	t = (double)(finish - start);//计算运行时间
  	printf("time = %lfms\n\n", t);//输出运行时间
  
  	//测试快速排序（随机）
  	fp1 = fopen("data1.dat", "rb");
  	fread(L.r, sizeof(RedType), MAXSIZE + 1, fp1);
  	fclose(fp1);
  
  	start = clock();     //开始
  	//printf("随机快速排序前：\n");
  	//print_Sq(L);  //打印结果
  
  	QSort(&L, 1, L.length);	
  	printf("随机快速排序比较次数为：%d\n", q_a);
  	printf("随机快速排序移动次数为：%d\n", q_b);
  	//printf("随机快速排序后：\n");
  	//print_Sq(L);  //打印结果
  
  	finish = clock();    //结束
  	t = (double)(finish - start);//计算运行时间
  	printf("time = %lfms\n\n", t);//输出运行时间
  
  	
  	//测试堆排序
  	fp1 = fopen("data1.dat", "rb");
  	fread(L.r, sizeof(RedType), MAXSIZE + 1, fp1);
  	fclose(fp1);
  
  	start = clock();     //开始
  	//printf("堆排序前：\n");
  	//print_Sq(L);  //打印结果
  
  	HeapSort(&L);
  	printf("堆排序比较次数为：%d\n", h_a);
  	printf("堆排序移动次数为：%d\n", h_b);
  	//printf("堆排序后：\n");
  	//print_Sq(L);  //打印结果
  
  	finish = clock();    //结束
  	t = (double)(finish - start);//计算运行时间
  	printf("time = %lfms\n\n", t);//输出运行时间
  	
  	//测试归并排序
  	fp1 = fopen("data1.dat", "rb");
  	fread(L.r, sizeof(RedType), MAXSIZE + 1, fp1);
  	fclose(fp1);
  
  	start = clock();     //开始
  	//printf("归并排序前：\n");
  	//print_Sq(L);  //打印结果
  
  	merge_sort(&L);
  	printf("归并排序比较次数：%d\n", m_a);
  	printf("归并排序移动次数：%d\n", m_b);
  	//printf("归并排序后：\n");
  	//print_Sq(L);  //打印结果
  
  	finish = clock();    //结束
  	t = (double)(finish - start);//计算运行时间
  	printf("time = %lfms\n\n", t);//输出运行时间
  	return 0;
  }
  
  //顺序表的初始化
  Status InitList_Sq(SqList* L)
  {
  	L->length = MAXSIZE;	
  
  	for (int i = 1; i <= MAXSIZE; i++)
  	{
  		L->r[i].key = rand();
  	}
  	return OK;
  }
  
  //冒泡排序
  void bubble_sort(SqList* L)
  {
  	int i, j;
  	int a = 0;	//比较次数
  	int b = 0;	//交换次数
  	RedType x; //交换时用于临时储存
  	for (i = 1; i <= L->length -1; i++)	//n个元素需要n-1趟冒泡排序
  	{
  		for (j = 1; j <= L->length - i; j++)	//第一趟需要比较n-1次，每一趟需要比较的元素减少一个
  		{
  			if (++a && L->r[j].key >L->r[j + 1].key) //发生逆序，则交换
  			{
  				x = L->r[j];
  				L->r[j] = L->r[j + 1];
  				L->r[j + 1] = x;
  				b++;
  			}
  		}
  	}
  	printf("冒泡排序比较次数为：%d\n", a);
  	printf("冒泡排序交换次数为：%d\n", b);
  	printf("冒泡排序移动次数为：%d\n", 3*b);
  }
  
  //简单选择排序
  void SelectSort(SqList* L)
  {
  	int i, k, j;
  	RedType x; //交换时用于临时储存
  	int a = 0;	//比较次数
  	int b = 0;	//交换次数
  	for (i = 1; i <= L->length - 1; i++)
  	{
  		k = i;	//开始时默认每趟的第一个为最小
  		for (j = i + 1; j <= L->length; j++)	//从默认位置之后的元素开始寻找最小的元素
  		{
  			if (++a && L->r[j].key < L->r[k].key)
  			{
  				k = j; //记录最小值位置
  			}				
  		}
  		//一趟执行完以后，交换L.r[i]与L.r[k]
  		if (k != i)	//如果最小的位置不是默认位置，则需要交换
  		{
  			x = L->r[i];
  			L->r[i] = L->r[k];
  			L->r[k] = x;
  			b++;
  		}
  	}
  	printf("简单选择排序比较次数为：%d\n", a);
  	printf("简单选择排序交换次数为：%d\n", b);
  	printf("简单选择排序移动次数为：%d\n",3*b);
  }
  
  //直接插入排序（使用哨兵）
  void InserSort(SqList* L)
  {
  	int i, j;
  	int a = 0;	//比较次数
  	int b = 0;	//移动次数
  	for (i = 2; i <= L->length; i++)	//从第二个元素开始插入到有序序列
  	{
  		if (++a && L->r[i].key < L->r[i - 1].key)	//判断新插入的元素是否比已排序的最后一个元素大，如果大则不需要移动元素
  		{
  			L->r[0] = L->r[i];//复制为哨兵
  			for (j = i - 1;++a && L->r[0].key < L->r[j].key; j--)	//从已排好序的序列的最后一个从后往前比较，如果大于哨兵，则后移
  			{
  				L->r[j + 1] = L->r[j];
  				b++;
  			}	//循环结束时代表第j位元素小于新插入元素，j+1位为要插入的位置
  			L->r[j + 1] = L->r[0]; //插入到正确位置
  			b++;
  		}		
  	}
  	printf("直接插入排序比较次数为：%d\n", a);
  	printf("直接插入排序移动次数为：%d\n", b);
  }
  
  //对顺序表L快速排序（递归）
  void QSort(SqList* L, int low, int high) 
  {
  	if (low < high) //长度大于1
  	{
  		//找中心点元素位置
  		int pivotloc;
  		pivotloc = Partition(L, low, high); //将L.r[low...high]一分为二，pivotloc为枢轴元素排好序的位置
  		QSort(L, low, pivotloc - 1); 	//对低子表递归排序
  		QSort(L, pivotloc + 1, high); //对高子表递归排序
  	}
  }
  
  int Partition(SqList* L, int low, int high)
  {
  	L->r[0] = L->r[low];
  	while (low < high)
  	{
  		while (low < high && ++q_a && L->r[high].key >= L->r[0].key)
  			high--;
  		L->r[low] = L->r[high];
  		q_b++;
  		while (low < high && ++q_a && L->r[low].key <= L->r[0].key)
  			low++;
  		L->r[high] = L->r[low];
  		q_b++;
  	}	//结束时，low和high都指向中心点元素应该在的位置
  	L->r[low] = L->r[0];
  	return low;	//返回中心点位置
  }
  
  //输出顺序表
  void print_Sq(SqList L)
  {
  	for (int i = 1; i <= L.length; i++)
  	{
  		printf("%d ", L.r[i]);
  	}
  	printf("\n");
  }
  
  //堆排序
  void HeapSort(SqList* L) 
  {
  	int i, n;
  	RedType tmp;
  	n = L->length;
  
  	for (i = n / 2; i >= 1; i--)	//i = n/2 找到最后一个非叶子结点
  	{
  		HeapAdjust(L, i, n); //建初始堆
  	}
  	for (i = n; i > 1; i--) //进行n-1趟排序
  	{
  		//根与最后一个元素交换
  		tmp = L->r[1];
  		L->r[1] = L->r[i];
  		L->r[i] = tmp;
  		h_b += 3;
  		HeapAdjust(L, 1, i - 1); //对R[1]到R[i-1]重新建堆
  	}
  }
  
  //堆调整（大根堆）
  void HeapAdjust(SqList* L, int s, int m)	//s为堆顶所在位置，m为最后一个元素所在位置
  {
  	//建大根堆，将最大的元素放在最后面，即完成了从小到大排序
  	int j;
  	RedType rc = L->r[s];	//保存堆顶元素
  	for (j = 2 * s; j <= m; j *= 2) //沿key较大的孩子向下筛选
  	{
  		if (j < m && ++h_a && (L->r[j].key < L->r[j + 1].key))
  		{
  			j++; //j为key较大的记录的下标
  		}
  		if (++h_a && rc.key >= L->r[j].key)	
  			break;
  		L->r[s] = L->r[j];
  		++h_b;
  		s = j; //rc应插入在位置s上
  	}
  	L->r[s] = rc; //插入
  	++h_b;
  }
  
  // 归并排序入口
  void merge_sort(SqList* L)
  {
  	RedType* a = (RedType*)malloc((MAXSIZE + 1)*sizeof(RedType));	//分配一个同样大小的辅助空间
  	if (a)	//辅助数组分配成功
  	{
  		msort(L, a, 1, L->length);
  		free(a);	//释放辅助空间
  	}
  	else
  	{
  		printf("error:分配失败！");
  	}
  }
  
  //归并排序
  void msort(SqList* L, RedType a[], int left, int right)	//原顺序表，辅助数组，左下标，右下标
  {
  	//如果只有一个元素，那么不需要继续划分
  	if (left < right)
  	{
  		int mid = (left + right) / 2;	//找中间点
  		msort(L, a, left, mid);	//递归继续划分，左半区
  		msort(L, a, mid + 1, right);	//右半区
  		merge(L, a, left, mid, right);	//当只有一个元素的时候开始合并
  	}
  }
  
  //合并
  void merge(SqList* L, RedType a[], int left, int mid, int right)
  {
  	//标记顺序表左半区第一个未排序的元素
  	int l_pos = left;
  	//标记顺序表左半区第一个未排序的元素
  	int r_pos = mid + 1;
  	//临时数组的下标
  	int pos = left;	//因为一个过程内需要合并的就是left到right这一部分
  	//合并
  	while (++m_a && l_pos <= mid && ++m_a && r_pos <= right)	//当左半区和右半区都还有元素时
  	{
  		if (++m_a && L->r[l_pos].key < L->r[r_pos].key)	//如果左半区第一个剩余元素小于右半区第一个元素
  		{
  			a[pos] = L->r[l_pos];	//将左半区元素放到辅助数组
  			pos++;
  			l_pos++;
  			++m_b;
  		}
  		else
  		{
  			a[pos] = L->r[r_pos];	//将右半区元素放到辅助数组
  			pos++;
  			r_pos++;
  			++m_b;
  		}
  	}
  	//合并左半区剩余的元素
  	while (++m_a && l_pos <= mid)
  	{
  		a[pos] = L->r[l_pos];	//将左半区元素放到辅助数组
  		pos++;
  		l_pos++;
  		++m_b;
  	}
  	//合并右半区剩余的元素
  	while (++m_a && r_pos <= right)
  	{
  		a[pos] = L->r[r_pos];	//将左半区元素放到辅助数组
  		pos++;
  		r_pos++;
  		++m_b;
  	}
  	//把临时数组中合并后的元素复制回原数组
  	while (left <= right)
  	{
  		L->r[left] = a[left];
  		left++;
  		++m_b;
  	}
  }
  ```

## 各类排序方法比较

|          |              |          | 时间复杂度 |          | 空间复杂度 |        |
| -------- | ------------ | -------- | ---------- | -------- | ---------- | ------ |
| 类别     | 排序方法     | 最好情况 | 最坏情况   | 平均情况 | 辅助储存   | 稳定性 |
| 插入排序 | 直接插入排序 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 插入排序 | 希尔排序     | O(n) | O(n^2) | O(n^1.3) | O(1) | 不稳定 |
| 交换排序 | 冒泡排序               | O(n) | O(n^2) | O(n^2) | O(1) |稳定|
| 交换排序 | 快速排序     | O(nlogn) | O(n^2) | O(nlogn) | O(nlogn) | 不稳定 |
| 选择排序 | 直接选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 选择排序 | 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n^2) | 不稳定 |
| 归并排序 | 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 基数排序 | 基数排序 | O(m+n) | O(k*(m+n)) | O(k*(m+n)) | O(m+n) | 稳定 |



